# 圈复杂度优化技巧

**一般来说：**

1. 圈复杂度高时通常伴随大量的卫语句，造成理解困难；
2. 降低圈复杂度时无脑拆分过多的子函数，会有入栈出栈的消耗；
3. 子函数逻辑尽量并列，减少逻辑嵌套；
4. 查表方式 替代switch case，数组特别大可以考虑用降维、函数封装，考虑用算法替代查表

当涉及到控制流程时，圈复杂度是一个非常重要的指标，可以帮助评估代码的可读性、可维护性和质量。以下是一些在C语言中降低圈复杂度的建议：

| 建议         | 说明                                                                                                                                  |
| ------------ | ------------------------------------------------------------------------------------------------------------------------------------- |
| 减少嵌套     | 嵌套语句越多，圈复杂度就越高。通过使用提前退出、提取函数、使用函数等方法可以减少嵌套。                                                |
| 减少case语句 | 大型switch语句通常具有高圈复杂度。减少switch语句中的case数量可以帮助降低圈复杂度。                                                    |
| 使用函数     | 将复杂的代码块拆分成独立的函数可以使代码更易于阅读和维护，同时可以降低圈复杂度。                                                      |
| 减少循环     | 循环通常是高圈复杂度代码的主要来源。可以使用现成的库函数来处理循环，例如标准库中的qsort()函数可以用来排序数组，不需要手写冒泡排序等。 |
| 减少条件语句 | 条件语句的嵌套会导致圈复杂度的增加。尝试使用位运算、函数指针、状态机等替代方案。                                                      |
| 使用goto语句 | 在某些情况下，使用goto语句可以使代码更清晰，而不是使用多重嵌套的循环或条件语句。但是，使用goto语句也会导致代码难以阅读和维护。        |
| 使用设计模式 | 设计模式是一些通用的解决方案，可以帮助降低圈复杂度并提高代码质量。一些常见的设计模式如单例模式、工厂模式、策略模式等。                |

尽可能使用清晰的变量名和函数名，这可以提高代码的可读性。
注释代码，特别是那些高圈复杂度的代码块，这可以帮助读者理解代码。
使用静态分析工具和代码审查来检查高圈复杂度的代码，找出并改进问题代码。
总之，圈复杂度是一个非常重要的概念，程序员应该尽可能地降低圈复杂度，从而使代码更易于理解、维护和修改。

**复杂度测试：**

| 程序变动行为                                                                                                                                                           | 圈复杂度变化 |
| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------ |
| case里面增加一个if                                                                                                                                                     | +1           |
| 增加一个空case                                                                                                                                                         | 无变化       |
| 增加一个case且增加一个2层嵌套if                                                                                                                                        | +4           |
| 增加一个带函数调用的case                                                                                                                                               | +1           |
| 增加一个没有副作用的case                                                                                                                                               | +1           |
| 在case中的if条件中在嵌套一个if，且一直往里面嵌套，则一直+1，只和if的数量有关，和if是否嵌套无关。<br />即嵌套不会导致指数级增长另外，把嵌套if改成并列if后，复杂度无变化 | +1           |
| 在case中增加一个if里面带调用函数的判断                                                                                                                                 | +3           |

**总结：**

- 一个case基本固定是复杂度+1
- 在case中增加一个无副作用的if，复杂度基本+1
- 在case中增加一个if且if里面带函数调用的话，复杂度剧增(+3)
- 在switch case中嵌套switch case，复杂度也是根据case数量+1(无副作用的case)
