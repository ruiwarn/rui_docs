## 8.1.指针和数组

### 【原则 8-1-1】： 指针的指针不应超过两级

**说明：**

指针指向地址，而二重指针指向“指针的地址”。

再多级的指针将难以理解，对阅读代码造成障碍。

**执行级别：** **强制**

**来源（规范标准）：** GB-T-28169-2011嵌入式软件C语言编码规范

### 【规则 8-1-1】： 不应对 `指针变量` 使用强制类型转换，赋值一个 `非指针变量`

**说明：**

除非已知明确的寄存器操作外，不能通过强制类型转换将向指针赋值一个非指针类型的数据。

**执行级别：** **强制**

**正例：**

```c
void foo (void)
{
  char* s_ptr = "ZERO"; 
  char* p1_ptr; 
  p1_prt = s_ptr;
  // ...
}
```

> **正例解析：**
> 将指针赋值给指针

**反例：**

```c
void foo (void)
{
  unsigned short number = 70; 
  unsigned int* p1_ptr; 
  p1_prt = (unsigned int*) number; // 将一个数字作为地址，赋值给指针
  // ...
}
```

> **反例解析：**
> 变量 `number` 是一个常量，但通过强制类型转换将其赋值给 `p1_prt`, 由于 `p1_prt` 指向未知地址，因此使用 `p1_prt` 时会产生未知影响。

**来源（规范标准）：** GB-T-28169-2011嵌入式软件C语言编码规范

### 【规则 8-1-2】： 指向不同数据类型的指针之间不应相互转换

**说明：**

不同的数据类型分配的字节空间可能不同,将 `指向多字节空间的指针` 转换为 `指向少字节空间的指针` 不会有间题，反之有可能出现错误。

在 `分配空间小的数据类型的指针` 强转成 `分配空间大的数据类型的指针`前，要确认没有超出已知空间，不会访问到未知数据。

**执行级别：** **建议**

**正例：**

```c
void foo (void)
{
  int sum = 10; 
  
  int*  p_prt = &sum;

  char* ch_prt = (char*)p_prt;
  // ...
}
```

> **正例解析：**
> 多字节的指针（`int*`）转换为少字节的指针（`char*`）时，由于数据类型占用的字节空间变短，因此不会出现异常访问的问题。

**反例：**

```c
void foo (void)
{
  char ch = 'c'; 
  
  char* ch_prt = &ch; 
  int*  p_prt = NULL;

  p_prt = (int*)ch_prt; // 这里将一个char指针，强转成int指针类型。
                    // 属于指向小空间的指针，强转成指向大空间的指针
  // ...
}
```

> **反例解析：**
> 少字节的指针（`char*`）转换为多字节的指针（`int*`）后，由于指向的数据类型占用的字节空间变长，因此会访问到未知的数据，可能出现未知问题。

**来源（规范标准）：** GB-T-28169-2011嵌入式软件C语言编码规范

### 【规则 8-1-3】： 指针转换过程中不应丢失指针的 const、volatile 属性

**说明：**

丢失 `const` 属性，将有可能导致在“只读内容”进行写操作，编译器不会发出警告；

丢失 `volatile` 属性，编译器将不对具有 `volatile` 属性的变量作优化，编译器的优化可能导致程序员预先设计的硬件时序操作失效，这样的错误很难发现。

**执行级别：** **强制**

**正例：**

```c
int x;
int * pi;               /* 指向整型的指针 */
int *const pcil = &x;   /* const 指针 */
const int * pci2;       /* 指向 const 整型的指针 */
volatile int * pci3;    /* 指向 volatile 整型的指针 */

pi = pcil;              /* 符合本条要求 */
pi = pci2;              /* 符合本条要求 */

```

**反例：**

```c
int x;
int * pi;               /* 指向整型的指针 */
int *const pcil = &x;   /* const 指针 */
const int * pci2;       /* 指向 const 整型的指针 */
volatile int * pci3;    /* 指向 volatile 整型的指针 */

pi = (int *) pci2;      /* 不符合本条要求 由于强转，导致 const 丢失 */
pi = (int *) pci3;      /* 不符合本条要求 由于强转，导致 volatie 丢失 */
```

> **反例解析：**
> 对于 `pi = (int *) pci2`, 由于对 `const` 修饰的指针变量进行强制类型转换，导致const类型丢失，导致后续对调用 `pi` 会对常量进行赋值。
>
> 对于 `pi = (int *) pci3`， 由于对 `volatile` 修饰的指针变量进行强制类型转换，导致 `volatile` 类型丢失，`volatile`效果失效。

**来源（规范标准）：** GB-T-28169-2011嵌入式软件C语言编码规范

### 【规则 8-1-4】：只有指向数组的指针才允许进行算术运算

**说明：**

此处的算术运算仅限于指针加减某个整数，比如 `ppoint = ppoint - 5` ，`ppoint++` 等。

**执行级别：** **强制**

**正例：**

```c
int* px; 
int a[10];
px = a;
px = px + 2;  // px = &a[2]
++px;         // px = &a[3]
```

**反例：**

```c
int* px;
int i;
px = &i;      // px 指向一个变量的地址
px = px + 2;  // 此时，对指针 px 做加减运算，*(px + 2) 将指向未知数据，对其指向的区域进行赋值将导致未知影响
++px;
```

**来源（规范标准）：** GB-T-28169-2011嵌入式软件C语言编码规范

### 【规则 8-1-5】：只有指向同一数组的两个指针才允许相减

**说明：**

指向不同数组的指针进行减法运算没有意义。

**执行级别：** **强制**

**正例：**

```c
int a [10];
int b [10];

int* p1 = a;
int* p2 = a[9];

int length;
length = p2 - p1; // x 表示数组中两数据间的间隔
```

**反例：**

```c
int a [10];
int b [10];

int* p1 = a;
int* p2 = b;

int x;
x = p1 - p2; // 由于p1 和 p2 指向不同的数组，计算出的结果意义不明
```

**来源（规范标准）：** GB-T-28169-2011嵌入式软件C语言编码规范

### 【规则 8-1-6】：只有指向同一数组的两个指针才允许用 `>` 、`>=` 、`<` 和 `<=` 等关系运算符进行比较

**说明：**

指向不同数组的指针进行关系比较没有意义。

**执行级别：** **强制**

**正例：**

```c
char a[10];

char* p1 = a;
char* p2 = a + 2;

bool x;
x = p1 < p2;      // 两个指针指向同一数组，进行比较以确认两者的在数组中的位置关系。
```

**反例：**

```c
char a[10];
char b[10];

char* p1 = a;
char* p2 = b;

bool x;
x = p1 < p2;      // 指向不同数组的指针，进行比较，没有意义。
```

**来源（规范标准）：** GB-T-28169-2011嵌入式软件C语言编码规范

### 【规则 8-1-7】：指针的索引值不应为负数

**说明：**
当出现在指针上使用索引时（例如出现 `p[2]` 的格式），一般情况下这个指针指向一个数组。

因此，当指针索引为负数时可能会指向未知区域，引发异常。

**执行级别：** **强制**

**正例：**

```c
void printf_num(int* p, int n)
{
    if (n < 0)
    {
        return;
    }
  
  printf("%d", p[n]);
}
```

> **正例解析：**
> 指针使用索引时，如 `p[n]`，将等价于 `*(p + n)`。因此，当 `n` 为正整数能更好的指向数组内部已知数据。

**反例：**

```c
void printf_num(int* p, int n)
{  
  printf("%d", p[n]); /* 和 r = p[n]等价，当 n 为负数，比如 -5，此时 p[n] = *(p-5)，将指向未知区域 */
}
```

> **反例解析：**
> 由于在 C 中`r = *(p + n)` 和 `r = p[n]` 在使用上等价，因此当数组指针的索引值为负数时，将指向数组外的数据，从而会出现未知的结果。

### 【规则 8-1-8】防止指针越界

**说明：**
如果动态计算一个地址时，要保证被计算的地址是合理的并指向某个有意义的地方。特别对于指向一个结构或数组的内部的指针，当指针增加或者改变后仍然指向同一个结构或数组。

**执行级别：** **强制**

### 【规则 8-1-9】防止数组越界

**说明1：**
由于C不会对数组进行有效的检测，因此必须在应用中显式的检测数组越界问题。

**执行级别：** **强制**

**正例1：**

```c
#define REC BUF LEN 100
unsigned char RecBuf[REC_BUF_LEN];
//其它代码
void Uart IRQHandler(void) 
{
    static s_RecCount = 8; //按收数据长质计嫩器
    //其它代码
    if (s_RecCount < REC_BUF_LEN) 
    { //判断数组是否越界
        RecBuf[s_RecCount]=....
        s_RecCount++;
        //其它代码
    }
    else 
    {
        //错误处理代码
    }
    //其它代妈
}
```

>正例解析：通过`if(s_RecCount < REC_BUF_LEN)` 进行数组越界判断，本例子可用于中断接收通讯数据。

**说明2：**
在使用一些库函数时，同样需要对边界进行检查，比如下面的`memset(RecBuf, 0, len)`函数把`RecBuf`指指向的内存区的前`len`个字节用`0`填充，如果不注意`len`的长度，就会将数组RecBuf之外的内存区清零：

**正例2：**

```c
#define REC BUF LEN 108
unsigned char RecBuf[REC_BUF_LEN];
if (len < REC_BUF_LEN) 
{
    memset(RecBuf, 0, len); // 将数组RecBuf清零
}
else 
{
// 处里错误
}
```

**引用知识（官网，书籍等）：**《华为C语言编程规范》
