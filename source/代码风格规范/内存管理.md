## 12.1.内存的申请

### 【规则 12-1-1】 使用malloc()等函数获取内存时，必须检查内存是否申请成功。

**说明：**
对内存分配成功做检查，防止内存分配失败，使用无效内存指针导致程序错误。

**执行级别：** **强制**

**正例：**
```c
char * name = (char *)malloc(sizeof(char) * 10);
if (name != NULL)
{
   name[2] = 'a';
}
```
> 正例解释：对内存分配成功进行了检查

**反例：**
```c
char * name = (char *)malloc(sizeof(char) * 10);
name[2] = 'a';
```
> 反例解释：未对内存分配成功进行检查，当内存分配不成功时会导致异常

**引用知识（官网，书籍等）：** 林锐博士的《高质量C++/C编程指南》

### 【规则 12-1-2】 分配好内存之后使用之前应对内存进行初始化。

**说明：**
如果没有手动清除，使用过的内存都会留存上一个使用该段内存程序所留下的值，不当使用可能导致程序错误。

**执行级别：** **建议**

**正例：**

```c++
char * state = (char *)malloc(sizeof(char) * 10);
int i,
int cnt = 0;
memset(state, 0, sizeof(char) * 10);
memcpy(state, "abcd", strlen("abcd"));
for (i = 0; i < 10; i++)
{
    if (state[i] != 0)
    {
        cnt++;
    }
}
```

> 正例解释：通过函数 `memset()`对通过 `malloc()`申请的内存进行了初始化处理。

**反例：**

```c
char* state = (char *)malloc(sizeof(char) * 10);
int i;
int cnt = 0;
memcpy(state, "abcd", strlen("abcd"));
for (i = 0; i < 10; i++)
{
    if (state[i] != 0)
    {
        cnt++;
    }
}
```

> 反例解释：未对 `malloc()`申请的内存进行初始化处理。

**引用知识（官网，书籍等）：** 林锐博士的《高质量C++/C编程指南》

### 【规则 12-1-3】 使用 `malloc()`等函数获取内存时,应对分配失败做异常处理。

**说明：**
做异常处理使错误处理和真正程序工作分开来，代码更易组织，更清晰，复杂的工作更容易实现，程序更安全，不至于一些小的疏忽导致程序崩溃。

**执行级别：** **建议**

**引用知识（官网，书籍等）：**《华为C语言编程规范》，林锐博士的《高质量C++/C编程指南》

### 【规则 12-1-4】 对于内存受限的系统，宜减少使用动态内存分配，多采用静态分配，在程序编译时就确定所需的空间。

**说明：**
在空间分配时编译时确定所需空间，能减少动态分配时内存不足导致的程序运行的错误和不可预知的风险。

**执行级别：** **建议**

**来源（规范标准）：** 《GB/T 28169-2011 嵌入式软件 C语言编码规范》

### 【规则 12-1-5】 对于内存受限的系统，在分配内存时，应考虑内存碎片的问题。

**说明：**
当通过 `malloc()`申请内存空间时，操作系统会从空闲内存链表中查找需要的内存空间，根据一定的策略，找到匹配的空间后，就将其标为已用，并从空闲链表中剥离，并给应用程序使用。
当有太多的内存碎片时，指空闲链表中有很多间隔的小空间，而导致较大的内存空间无法申请。

**执行级别：** **建议**

**来源（规范标准）：**《GB/T 28169-2011 嵌入式软件 C语言编码规范》

### 【规则 12-1-6】 内存申请大小必须大于0。

**说明：**
使用0字节长度申请内存的行为是没有定义的，在引用内存申请函数返回地址时会引发不可预知的错误，使用负数申请内存，负数会被当成一个很大的无符号整数，导致内存申请过大而导致失败。

**执行级别：** **建议**

**引用知识（官网，书籍等）：** 林锐博士的《高质量C++/C编程指南》

### 【规则 12-1-7】  结构体分配内存时成员指针初始化时也要分配内存。

**说明：**
为结构体分配内存时，只是对结构体成员元素分配内存。

**执行级别：** **强制**

**正例：**

```c
typedef struct 
{
    char * name;
    int count;
}stu;

void tmepFun(void)
{
   stu *stuData = NULL; 
   stuData = (stu *)malloc(sizeof(stu));
    if (stuData != NULL)
    {
       stuData->name = (stu *)malloc(sizeof(char) * 10);
        if (stuData->name != NULL)
        {
            stuData->name[3] = 'p';
            //....
        }
    }
}
```

> 正例解释：通过 `malloc()`给结构体以及结构体指针成员 `name`分配内存。

**反例：**

```c
typedef struct 
{
    char * name;
    int count;
}stu;
void tmepFun(void)
{
    stu * stuData = NULL; 
    stuData = (stu *)malloc(sizeof(stu));
    if(stuData != NULL)
    {
       stuData->name[3] = 'a';   
        //...  
    }
}
```

> 反例解释：未给结构体指针成员 `name`分配内存,导致 `name`成一个野指针。

**引用知识（官网，书籍等）：** 林锐博士的《高质量C++/C编程指南》

### 12.2.内存的释放

#### 【规则 12-2-1】 申请的内存与释放要配对，防止内存泄露。

**说明：**
过程或函数中分配的内存，在过程，函数退出之前要释放，过程或函数中申请（为打开文件而使用的）文件句柄，在过程函数退出之前要关闭。

**执行级别：** **强制**

**正例：**

```c
void tempFun(void)
{
    char * link = (char*)malloc(sizeof(char) * 10);
    FILE * fp;
    fp = fopen("D://temp.txt","r");
    //.....
    free(link);
    link = NULL;
    fclose(fp);
    fp = NULL;
}
```

> 正例解释：对通过 `malloc()`分配的内存进行了内存释放。对打开的文件句柄，在函数退出之前进行了关闭处理。

**反例：**

```c
void tempFun(void)
{
    char * link = NULL;
    link = (char*)malloc(sizeof(char) * 10);
    FILE * fp = NULL;
    fp = fopen("D://temp.txt","r");
    //.....   
}
```

> 反例解释：未对通过 `malloc()`分配的内存进行内存释放，会导致内存泄漏。对打开的文件句柄，在函数退出之前未关闭。

**引用知识（官网，书籍等）：** 林锐博士的《高质量C++/C编程指南》

**来源（规范标准）：** 《GB/T 28169-2011 嵌入式软件 C语言编码规范》

### 【规则 12-2-2】 禁止或函数内返回非动态申请的内存（栈中的内存，函数中的临时变量等）。

**说明：**

**执行级别：** **强制**

**引用知识（官网，书籍等）：** 林锐博士的《高质量C++/C编程指南》

## 12.3.内存的使用

### 【规则 12-3-1】 不应使用已释放的内存空间。

**说明：**
已释放的内存空间，可能已经被别的程序使用，当再次使用这块内存，可能导致程序不可预测的错误。

**执行级别：** **强制**

**来源（规范标准）：** 《GB/T 28169-2011 嵌入式软件 C语言编码规范》

### 【规则 12-3-2】 应防止越界操作，数组，指针，内存地址等内存空间。

**说明：**
越界操作可能引发程序不可预测的错误或程序崩溃。

**执行级别：** **强制**

**正例：**

```c
void tempFun(void)
{
    char arr[TEM_MAX_SIZE] = {0};
    char * name = (char *)malloc(sizeof(char) * TEM_MAX_SIZE);
    ....
    arr[TEM_MAX_SIZE - 1] = 'p';
    name[TEM_MAX_SIZE - 1] = 'a';
}
```

> 正例解释：

**反例：**

```c
void tempFun(void)
{
    char arr[TEM_MAX_SIZE] = {0};
    char * name = (char *)malloc(sizeof(char) * TEM_MAX_SIZE);
    ....
    arr[TEM_MAX_SIZE] = 'p';
    name[TEM_MAX_SIZE] = 'a';
}
```

> 反例解释：数组 `arr[TEM_MAX_SIZE]`和 `name [TEM_MAX_SIZE]`越界。

**引用知识（官网，书籍等）：** 林锐博士的《高质量C++/C编程指南》

**来源（规范标准）：** 《GB/T 28169-2011 嵌入式软件 C语言编码规范》

### 【规则 12-3-3】 对于动态分配的内存指针和文件句柄，在定义的时候应初始化为空，访问的时候应判断是否为空，在释放完后应设为空。

**说明：**

**执行级别：** **要求**

**正例：**

```c
void tempFun(void)
{
    char * link = NULL;
    (char *)malloc(sizeof(char) * 10);
    FILE * fp ;
    fp = fopen("D://temp.txt","r");
    //.....
    if(link != NULL)
    {
        free(link);
        link = NULL;
    }
    if(fp != NULL)
    {
        fclose(fp);
        fp = NULL;
    }
}
```

> 正例解释：

**反例：**

```c
void tempFun(void)
{
    char * link;
    link = (char *)malloc(sizeof(char) * 10);
    FILE * fp ;
    fp = fopen("D://temp.txt","r");
    //.....
    free(link);
    fclose(fp);
}
```

> 反例解释：

**引用知识（官网，书籍等）：** 林锐博士的《高质量C++/C编程指南》

**来源（规范标准）：** 《GB/T 28169-2011 嵌入式软件 C语言编码规范》

### 【规则 12-3-1】 字符串连接宜使用strncat库函数代替strcat库函数，字符串拷贝宜使用strncpy库函数代替strcpy库函数，避免长度不够引起的数组越界。

**说明：**

**执行级别：** **建议**

**来源（规范标准）：** 《GB/T 28169-2011 嵌入式软件 C语言编码规范》

### 【建议 12-3-2】 使用sprintf库函数时，应注意字符串长度，避免长度不够引起的数组越界。

**说明：**

**执行级别：** **建议**

**正例：**

> 正例解释：

**反例：**

> 反例解释：

**来源（规范标准）：** 《GB/T 28169-2011 嵌入式软件 C语言编码规范》
