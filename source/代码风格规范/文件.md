## 3.1.文件目录

### 【规则 3-1-1】不要所有代码文件放在一个文件夹，而是分“文件夹”保存

**说明：**

1. 如果一个软件的文件数目比较多（如超过十个），找源码文件会比较慢。因此，需要分文件夹来储存不同功能模块的代码。这样寻找文件夹较为容易找到源码文件。
2. 如果一个功能模块的头文件数目比较多（如超过十个），通常应将头文件和定义文件分别保存于不同的目录，以便于维护。可将头文件保存于include目录，将定义文件保存于source目录（可以是多级目录）。
3. 如果某些头文件是私有的，它不会被用户的程序直接引用，则没有必要公开其“声明”。为了加强信息隐藏，这些私有的头文件可以和定义文件存放于同一个目录。

**执行级别：** **要求**

## 3.2.文件说明

### 【原则 3-2-1】源文件和头文件的开头需要有文件说明

**说明：**
文件说明主要内容有：

1. 版权信息。
2. 文件名称，标识符，摘要。
3. 当前版本号，作者/修改者，完成日期。
4. 版本历史信息,可根据实际情况决定是否添加，一般是对外接口的变化需要说明

**执行级别：** **要求**

**正例：**

```c
/*************************************************
Copyright (C), 2018-2028, zcpower Technology, Inc.
File name: // 文件名
Author: Version: Date: // 作者、版本及完成日期
Description: // 用于详细说明此程序文件完成的主要功能，与其他模块
// 或函数的接口，输出值、取值范围、含义及参数间的控
// 制、顺序、独立或依赖等关系
Others: // 其它内容的说明
Function List: // 主要函数列表，每条记录应包括函数名及功能简要说明
1. ....
History: // 修改历史记录列表，每条修改记录应包括修改日期、修改
// 者及修改内容简述
1. Date:
Author:
Modification:
1. ...
*************************************************/
```

> 正例解析：这段头文件的头注释比较标准,可以以此为参考，不限于此格式。

**引用知识（官网，书籍）：**  《华为C语言编程规范》

## 3.3.源文件

### 【原则 3-3-1】源文件结构

**说明：**

一般说来，源文件的整体构成包括以下内容（有时可能不存在某些部分）：
源文件的注释框、包含文件部分、宏定义部分、类型定义部分、结构体定义部分、全局变量定义部分、文件static变量定义部分、函数原型声明、调试开关定义部分、 函数定义部分。各节之前要有表示节开始的注释框。

**执行级别：** **建议**

**示例：**

```c
// 版权和版本声明见【原则3-2-1】之正例，此处省略。

#include "graphics.h"   // 引用头文件

#define READ_BUF_SIZE 256   // 宏定义
int resultnormal_buff[128];

// 全局函数的实现体
void Function1(...)
{
}
```

**引用知识（官网，书籍）：** 林锐博士的《高质量C++/C编程指南》

### 【规则 3-3-1】一个文件的长度不要超过2000行代码

**说明：**

1. 一个文件中包含超过2000行的代码较难阅读，所以应该按照逻辑功能划分成多个文件。
2. 一个文件中包含超过2000行的代码，说明这个文件的功能不够单一。

**执行级别：** **要求**

**引用知识（官网，书籍）：** 《华为C语言编程规范》

### 【建议3-3-1】文件中的#include 语句之前只能是其他预处理指令或注释。

**说明：**
代码文件中所有#include 指令应该成组放置在接近文件顶部的位置。本规则说明，文件中可以优先#include 语句放置的只能是其他预处理指令或注释

**执行级别：** **建议**

**正例：**

```c
// 版权和版本声明

#define __PRGAPHICS_C__

#include "graphics.h"   // 引用头文件

#undef __PRGAPHICS_C__
```

> 正例解析：在“#include ”前面使用“#define”来防止重复包含，这样可以使用。

**反例：**

```c
// 版权和版本声明


#define READ_BUF_SIZE 256   // 宏定义
static int s_resultnormal_buff[128];

#include "graphics.h"   // 引用头文件，放在“#define”定义的常量和变量定义之后

```

> 反例解析：“#include”放在“#define”定义的常量和变量定义之后，虽然编译不报错，但不推荐使用，影响阅读体验。

**来源（规范标准）：** 《MISRA_C_2004中文版》

## 3.4. 头文件

### 【原则 3-4-1】头文件结构

**说明：**
头文件由三部分内容组成：

1. 头文件开头处的版权和版本声明。
2. 预处理块。
3. 变量、函数声明等。

**执行级别：** **建议**

**正例：**

```c
// 版权和版本声明见【原则3-2-1】之正例，此处省略。

#ifndef __GRAPHICS_H__    // 防止graphics.h被重复引用
#define __GRAPHICS_H__

#include <math.h>       // 引用标准库的头文件

#include “myheader.h”   // 引用非标准库的头文件

extern void Function1(...);      // 全局函数声明

class Box               // 类结构声明,适用于C++编码
{
};
#endif
```

**引用知识（官网，书籍）：**  林锐博士的《高质量C++/C编程指南》

### 【原则 3-4-2】头文件中只存放“声明”，而不存放“实现”

**说明：**

1. 头文件是模块（Module）或单元（Unit）的对外接口。头文件中应放置对外部的声明，如对外提供的函数声明、宏定义、类型定义等。
2. 内部使用的函数（相当于类的私有方法）声明不应放在头文件中。
3. 内部使用的宏、枚举、结构定义不应放入头文件中。变量定义不应放在头文件中，应放在.c文件中。
4. 变量的声明尽量不要放在头文件中，亦即尽量不要使用全局变量作为接口。变量是模块或单元的内部实现细节，不应通过在头文件中声明的方式直接暴露给外部，应通过函数接口的方式进行对外暴露。 即使必须使用全局变量，也只应当在.c中定义全局变量，在.h中仅声明变量为全局的。
5. 全局函数声明时需加extern。

**执行级别：** **强制**

**引用知识（官网，书籍）：**  《华为C语言编程规范》，林锐博士的《高质量C++/C编程指南》《 C语言接口与实现》

**来源（规范标准）：**  《MISRA_C_2004中文版》

### 【原则 3-4-3】头文件应当职责单一

**说明：**

1. 头文件过于复杂，依赖过于复杂是导致编译时间过长的主要原因。很多现有代码中头文件过大，职责过多，再加上循环依赖的问题，可能导致为了在.c中使用一个宏，而包含十几个头文件。

**执行级别：** **强制**

**反例：**
如下是某平台定义WORD类型的头文件：

```c
#include <VXWORKS.H>
#include <KERNELLIB.H>
#include <SEMLIB.H>
#include <INTLIB.H>
#include <TASKLIB.H>
#include <MSGQLIB.H>
#include <STDARG.H>
#include <FIOLIB.H>
#include <STDIO.H>
#include <STDLIB.H>
#include <CTYPE.H>
#include <STRING.H>
#include <ERRNOLIB.H>
#include <TIMERS.H>
#include <MEMLIB.H>
#include <TIME.H>
#include <WDLIB.H>
#include <SYSLIB.H>
#include <TASKHOOKLIB.H>
#include <REBOOTLIB.H>
...
typedef unsigned short WORD;
...
```

> 反例解析：这个头文件不但定义了基本数据类型WORD，还包含了stdio.h syslib.h等等不常用的头文件。如果工程中有10000个源文件，而其中100个源文件使用了stdio.h的printf，由于上述头文件的职责过于庞大，而WORD又是每一个文件必须包含的，从而导致stdio.h/syslib.h等可能被不必要的展开了9900次，大大增加了工程的编译时间。

**引用知识（官网，书籍）：** 《华为C语言编程规范》，林锐博士的《高质量C++/C编程指南》

### 【原则3-4-4】头文件应向稳定的方向包含

**说明：**

1. 头文件的包含关系是一种依赖，一般来说，应当让不稳定的模块依赖稳定的模块，从而当不稳定的模块发生变化时，不会影响（编译）稳定的模块。
2. 就我们的产品来说，依赖的方向应该是：产品依赖于平台，平台依赖于标准库。
3. 某产品线平台的代码中已经包含了产品的头文件，导致平台无法单独编译、发布和测试，是一个非常糟糕的反例。

**执行级别：** **强制**

**正例：**

```c
// Foo.h中包含头文件的顺序如下：
// 本例中包含文件增加了路径，是为了更清晰的体现.h所在的模块，实际编码时参考:“【规则 3-4-6】 对头文件的包含不体现路径”。
#include <stdlib.h>                 // c/c++标准库的.h
#include <string.h>
#include <linux/list.h>             // 系统库的.h
#include <linux/time.h>
#include "platform/Base.h"          // 平台库的.h
#include "platform/Framework.h"
#include "project/public/Log.h"     // 本项目内其他的.h
```

> 正例解析：按c/c++标准库头文件，系统库头文件，平台头文件和本项目内其它需要用的头文件顺序包含。

**反例：**

```c
// framework.h（平台文件）中包含头文件的顺序如下：
#include <stdlib.h>                 // c/c++标准库的.h
#include <string.h>
#include <linux/list.h>             // 系统库的.h
#include <linux/time.h>
#include "platform/Base.h"          // 平台库的.h
#include "project/public/Log.h"     // 本项目内其他的.h
```

> 正例解析：平台的代码"framework.c"中已经包含了产品的头文件“Log.h”，导致平台无法单独编译、发布和测试。

**引用知识（官网，书籍）：**  《华为C语言编程规范》

### 【规则 3-4-1】为了防止头文件被重复引用，应采用#ifndef/#define/#endif的方式来防止多次被包含，其中使用的宏名为：“ __ ”+“文件名”+“_”+“扩展名”+“ __ ”，文件名与扩展名均为大写

**说明：**

**执行级别：** **强制**

**正例：**

```c
#ifndef __GRAPHICS_H__   // 防止graphics.h被重复引用
#define __GRAPHICS_H__
#include "xxx.h" 

extern void foo(...);
#endif
```

> 正例解析：采用#ifndef/#define/#endif的方式来防止多次被包含。

**反例：**

```c
#include "xxx.h"  

extern void foo(...);

```

> 反例解析：未用#ifndef/#define/#endif的方式来防止多次被包含

**引用知识（官网，书籍）：** 《华为C语言编程规范》，林锐博士的《高质量C++/C编程指南》

### 【规则 3-4-2】 用 #include <filename.h> 格式来引用标准库的头文件

**说明：**
 #include <filename.h> 格式，编译器将从标准库目录开始搜索。

**执行级别：** **强制**

**正例：**

```c
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
```

> 正例解析：包含的头文件为标准库的头文件，从标准库目录开始搜索，可节约搜索时间。

**反例：**

```c
#include “string.h”
#include “stdlib.h”
#include “stdio.h”
```

> 反例解析：包含的头文件为标准库的头文件，从用户工作目录开始搜索，增加了搜索时间。

**引用知识（官网，书籍）：**  林锐博士的《高质量C++/C编程指南》

### 【规则 3-4-3】用 #include “filename.h” 格式来引用非标准库的头文件

**说明：**
 #include “filename.h” 格式，编译器将从用户的工作目录开始搜索。

**执行级别：** **强制**

**正例：**

```c
#include "datatype.h"
#include "dlt698_event.h"
#include "energy.h"
```

> 正例解析：包含的头文件为工作目录的头文件，从用户工作目录开始搜索。

**反例：**

```c
#include <datatype.h>
#include <dlt698_event.h>
#include <energy.h>
```

> 反例解析：包含的头文件为工作目录的头文件，从标准库目录开始搜索，增加了搜索时间。

**引用知识（官网，书籍）：**  林锐博士的《高质量C++/C编程指南》

### 【规则 3-4-4】 每一个.c文件应有一个同名.h文件，用于声明需要对外公开的接口

**说明：**

1. 如果一个.c文件不需要对外公布任何接口，则其就不应当存在，除非它是程序的入口，如main函数所在的文件。
2. 在头文件中声明的函数或变量，一定是需要被其它文件使用的。函数声明建议加上extern。

**执行级别：** **强制**

**正例：**

```c
// xxx.c文件

static void bar(void) 
{
     Do something;
}

void Foo(...) 
{
    ...
    bar();
    ...
}
 
// xxx.h 文件
extern void Foo(...);

```

> 正例解析：函数bar()仅在本文件中使用，应当在.c的头部声明，并声明为static。 函数foo()为外部调用函数，在头文件中声明。

**反例：**

```c
// xxx.c文件
void Foo(...) 
{
    ...
    bar();
    ...
}
 
void bar(void) 
{
    Do something;
}

// xxx.h 文件
extern void bar(void);
extern void Foo(...);

```

> 反例解析：函数bar()仅在本文件中使用，无需在头文件中申明。

**引用知识（官网，书籍）：** 《华为C语言编程规范》，林锐博士的《高质量C++/C编程指南》

### 【规则 3-4-5】 文件及函数命名不允许与所使用的标准库或SDK命名相同

**说明：**

1. 对于.o目标文件，函数命名相同，编译时会报错。
2. 对于静态库（.a文件），函数命名相同，编译时不报错，但是程序只链接了一个函数，可能产生意外的结果。
3. 对于动态库（.so文件）,函数命名相同，编译时不报错，动态链接库只有在运行时才会动态加载，并且加载的顺序是由编译时链接的顺序决定,可能产生意外的结果。

**执行级别：** **强制**

**引用知识（官网，书籍）：** 无

### 【规则 3-4-6】 对头文件的包含不体现路径。通过工程配置解决包含路径，工程配置采用相对路径

**说明：**
1.有的情况会将头文件放在一个统一的文件中，头文件体现路径后会引起编译异常。
2.工程配置采用相对路径，当工程位置变化时，无需重新修改工程配置。

**执行级别：** **强制**

**正例：**

```c
#include "afg.h"
```

> 正例解析：包含的头文件不体现路径。

**反例：**

```c
#include "/include/afg.h"
#include "D:/App/include/afg.h"
```

> 反例解析：绝对路径，当工程位置变化时，需要更改路径

**引用知识（官网，书籍）：**

### 【规则 3-4-7】禁止头文件循环依赖。

**说明：**
头文件循环依赖，指a.h包含b.h，b.h包含c.h，c.h包含a.h之类导致任何一个头文件修改，都导致所有包含了a.h/b.h/c.h的代码全部重新编译一遍。而如果是单向依赖，如a.h包含b.h，b.h包含c.h，而c.h不包含任何头文件，则修改a.h不会导致包含了b.h/c.h的源代码重新编译。

**执行级别：** **强制**

**正例：**

```c
#ifndef __A_H__  // a.h
#define  __A_H_
#include "b.h"
...
#endif

#ifndef __B_H__  // b.h
#define  __B_H__
#include "c.h"
...
#endif

#ifndef __C_H__  // c.h
#define __C_H__
...
#endif
```

> 正例解析：修改头文件a.h，不会导致包含了b.h/c.h的源代码重新编译。

**反例：**

```c
#ifndef __A_H__  // a.h
#define  __A_H__
#include "b.h"
...
#endif

#ifndef __B_H__  // b.h
#define  __B_H__
#include "c.h"
...
#endif

#ifndef __C_H__   // c.h
#define __C_H__
#include "a.h"
...
#endif
```

> 反例解析：头文件循环依赖，任何一个头文件修改，都导致所有包含了a.h/b.h/c.h的代码全部重新编译一遍。

**引用知识（官网，书籍）：** 《华为C语言编程规范》

### 【规则 3-4-8】.c/.h文件禁止包含用不到的头文件

**说明：**
很多系统中头文件包含关系复杂，开发人员为了省事起见，可能不会去一一钻研，直接包含一切想到的头文件，甚至有些产品干脆发布了一个god.h，其中包含了所有头文件，然后发布给各个项目组使用，这种只图一时省事的做法，导致整个系统的编译时间进一步恶化，并对后来人的维护造成了巨大的麻烦。

**执行级别：** **强制**

**引用知识（官网，书籍）：** 《华为C语言编程规范》

### 【规则 3-4-9】头文件应当自包含

**说明：**

1. 简单的说，自包含就是任意一个头文件均可独立编译。如果一个文件包含某个头文件，还要包含另外一个头文件才能工作的话，就会增加交流障碍，给这个头文件的用户增添不必要的负担。
2. 本规则需要与“【规则3-4-7】.c/.h文件禁止包含用不到的头文件”规则一起使用，不能为了让a.h自包含，而在a.h中包含不必要的头文件。a.h要刚刚可以自包含，不能在a.h中多包含任何满足自包含之外的其他头文件。

**执行级别：** **强制**

**示例：**

如果a.h不是自包含的，需要包含b.h才能编译，会带来的危害：
每个使用a.h头文件的.c文件，为了让引入的a.h的内容编译通过，都要包含额外的头文件b.h。
额外的头文件b.h必须在a.h之前进行包含，这在包含顺序上产生了依赖。这种情况可以将b.h包含到a.h头文件中；但需要注意b.h是必须的包含。

**引用知识（官网，书籍）：**  《华为C语言编程规范》

### 【规则 3-4-10】禁止在头文件中定义变量

**说明：**
在头文件中定义变量，将会由于头文件被其他.c文件包含而导致变量重复定义。

**执行级别：** **要求**

**引用知识（官网，书籍）：**  《华为C语言编程规范》

### 【规则 3-4-11】只能通过包含头文件的方式使用其他.c提供的接口，禁止在.c中通过extern的方式使用外部函数接口、变量

**说明：**
若a.c使用了b.c定义的foo()函数，则应当在b.h中声明extern int foo(int input)；并在a.c中通过#include <b.h>来使用foo。禁止通过在a.c中直接写extern int foo(int input);来使用foo，后面这种写法容易在foo改变时可能导致声明和定义不一致。

**执行级别：** **强制**

**引用知识（官网，书籍）：**  《华为C语言编程规范》

### 【规则 3-4-12】禁止在extern "C"中包含头文件。适用于C与C++混编的情况

**说明：**

1. 在extern "C"中包含头文件，会导致extern "C"嵌套，Visual Studio对extern "C"嵌套层次有限制，嵌套层次太多会编译错误。
2. 在extern "C"中包含头文件，可能会导致被包含头文件的原有意图遭到破坏。

**执行级别：** **强制**

**正例：**

```c
#include "xxx.h"

extern "C" 
{
...
}
```

> 正例解析：在extern "C"前包含头文件，防止链接规范被不正确地更改。

**反例：**

```c
extern "C" 
{
#include "xxx.h"   // 在extern "C"中包含头文件
...
}
```

```c
// a.h 文件
#ifndef __A_H__
#define __A_H__

#ifdef __cplusplus
void foo(int);
#define a(value) foo(value)
#else
void a(int)
#endif

#endif /* __A_H__ */

// a.h 文件
#ifndef __B_H__
#define __B_H__

#ifdef __cplusplus
extern "C" 
{
#endif

#include "a.h"
void b();
#ifdef __cplusplus
}
#endif

#endif /* __B_H__ */
```

> 反例解析：使用C++预处理器展开b.h，将会得到

```c
extern "C" 
{
     void foo(int);
     void b();
}
```

> 按照a.h作者的本意，函数foo是一个C++自由函数，其链接规范为"C++"。但在b.h中，由于#include "a.h"被放到了extern "C" { }的内部，函数foo的链接规范被不正确地更改了。

**引用知识（官网，书籍）：**  《华为C语言编程规范》

### 3.4.17.【规则 3-4-13】禁止反向依赖

**说明：**

(1) 在软件设计中为了建立清晰的软件分层关系，引入了软件分层设计，高层模块可以依赖底层模块，底层模块不能依赖高层模块。比如业务层依赖于平台层，平台层不能依赖业务层。

**执行级别：** **强制**

**正例：**

```c
// Framework.h中包含头文件的顺序如下：
// 本例中包含文件增加了路径，是为了更清晰的体现.h所在的模块，实际编码时参考:“【规则 3-4-6】 对头文件的包含不体现路径”。
#include <stdlib.h>                // c/c++标准库的.h
#include <string.h>
#include <linux/list.h>            // 系统库的.h
#include <linux/time.h>            // 系统库的.h
#include "platform/Base.h"         // 平台库的.h
```

> 正例解析：平台文件仅包含平台库文件及其底层模块的h文件。

**反例：**

```c
// Framework.h文件中
#include <stdlib.h>                // c/c++标准库的.h
#include <string.h>
#include <linux/list.h>            // 系统库的.h
#include <linux/time.h>            // 系统库的.h
#include "platform/Base.h"         // 平台库的.h
#include "platform/Framework.h"   
#include "project/public/Log.h"    // 本项目内其他的.h 
```

> 反例解析：平台文件包含了项目中业务层的h文件，形成了反向依赖,这导致平台文件无法单独编译、发布和测试。

### 3.4.18.【规则 3-4-14】每个c文件仅包含自身的h文件。

**说明：**
(1)若在c文件中包含了其他模块的h文件，编译器不能发现循环依赖，从而将问题隐藏起来了，而在h文件中进行包含则可能会编译报错，可以及时发现并修改问题。

**执行级别：** **强制**

**正例：**

```c
// Foo.C文件中
#include "Foo.h"

void fun()
{
...
}
```

> 正例解析：Foo.c文件仅包含自身的Foo.h文件。

**反例：**

```c
// Foo.c文件中
#include "Foo.h"
#include "Log.h"    // 本项目内其他的.h 

void fun()
{
...
}
```

> 反例解析：在源文件Foo.c中还包含了"Log.h"，若"Foo.h"和 "Log.h"存在循环依赖，可能正常编译，这样可能将问题隐藏起来。

### 【建议 3-4-1】不提倡使用全局变量

**说明：**
尽量不要在头文件中出现象extern int g_value 这类声明

**执行级别：** **建议**

**引用知识（官网，书籍）：**  《华为C语言编程规范》，林锐博士的《高质量C++/C编程指南》

### 【建议 3-4-2】一个模块通常包含多个.c文件，建议放在同一个目录下，目录名即为模块名。为方便外部使用者，建议每一个模块提供一个.h，文件名为目录名

**说明：**
需要注意的是，这个.h并不是简单的包含所有内部的.h，它是为了模块使用者的方便，对外整体提供的模块接口。
以Google test（简称GTest）为例，GTest作为一个整体对外提供C++单元测试框架，其1.5版本的gtest工程下有6个源文件和12个头文件。但是它对外只提供一个gtest.h，只要包含gtest.h即可使用GTest提供的所有对外提供的功能，使用者不必关系GTest内部各个文件的关系，即使以后GTest的内部实现改变了，比如把一个源文件c拆成两个源文件，使用者也不必关心，甚至如果对外功能不变，连重新编译都不需要。
对于有些模块，其内部功能相对松散，可能并不一定需要提供这个.h，而是直接提供各个子模块或者.c的头文件。
比如产品普遍使用的VOS，作为一个大模块，其内部有很多子模块，他们之间的关系相对比较松散，就不适合提供一个vos.h。而VOS的子模块，如Memory（仅作举例说明，与实际情况可能有所出入），其内部实现高度内聚，虽然其内部实现可能有多个.c和.h，但是对外只需要提供一个Memory.h声明接口。

**执行级别：** **建议**

**引用知识（官网，书籍）：** 《华为C语言编程规范》

### 【建议 3-4-3】 如果一个模块包含多个子模块，则建议每一个子模块提供一个对外的.h，文件名为子模块名

**说明：**
降低接口使用者的编写难度。

**执行级别：** **建议**

**引用知识（官网，书籍）：**  《华为C语言编程规范》

### 【建议 3-4-4】头文件不要使用非习惯用法的扩展名，如.inc

**说明：**

1. 目前很多产品中使用了.inc作为头文件扩展名，这不符合c语言的习惯用法。在使用.inc作为头文件扩展名的产品，习惯上用于标识此头文件为私有头文件。但是从产品的实际代码来看，这一条并没有被遵守，一个.inc文件被多个.c包含比比皆是。
2. 使用.inc还导致source insight、Visual stduio等IDE工具无法识别其为头文件，导致很多功能不可用，如“跳转到变量定义处”。虽然可以通过配置，强迫IDE识别.inc为头文件，但是有些软件无法配置，如Visual Assist只能识别 .h 而无法通过配置识别 .inc。

**执行级别：** **建议**

**引用知识（官网，书籍）：** 《华为C语言编程规范》

### 【建议3-4-5】同一产品统一包含头文件排列方式，建议采样稳定度排序：c/c++标准库的.h，系统库的.h，平台库的.h，本项目内其他的.h

**说明：**
使用标准的头文件包含顺序可增强可读性，避免隐藏依赖。

**执行级别：** **建议**

**正例：**

```c
// Foo.h中包含头文件的顺序如下：
// 本例中包含文件增加了路径，是为了更清晰的体现.h所在的模块，实际编码时参考:“【规则 3-4-6】 对头文件的包含不体现路径”。
#include <stdlib.h>                // c/c++标准库的.h
#include <string.h>
#include <linux/list.h>            // 系统库的.h
#include <linux/time.h>            // 系统库的.h
#include "platform/Base.h"         // 平台库的.h
#include "platform/Framework.h"   
#include "project/public/Log.h"    // 本项目内其他的.h 
```

> 正例解析：按标准库头文件，系统库头文件，平台头文件和本项目内其它需要用的头文件顺序包含。

**反例：**

```c
// Foo.h中包含头文件的顺序如下：
// 本例中包含文件增加了路径，是为了更清晰的体现.h所在的模块，实际编码时参考:“【规则 3-4-6】 对头文件的包含不体现路径”。
#include <linux/list.h>            // 系统库的.h
#include <linux/time.h>            // 系统库的.h
#include "platform/Base.h"         // 平台库的.h
#include "platform/Framework.h"   
#include <stdlib.h>                // c/c++标准库的.h
#include <string.h>
#include "project/public/Log.h"    // 本项目内其他的.h 
```

> 反例解析：包含头文件没有按顺序排列，c/c++标准库的.h放在了平台库.h后面。

**引用知识（官网，书籍）：**  《华为C语言编程规范》
