嵌入式产品的可靠性自然与硬件密不可分，但在硬件确定、并且没有第三方测试的前提下，使用防御性编程思想写出的代码，往往具有更高的稳定性。

防御性编程首先需要认清C语言的种种缺陷和陷阱，C语言对于运行时的检查十分弱小，需要程序员谨慎的考虑代码，在必要的时候增加判断；防御性编程的另一个核心思想是假设代码运行在并不可靠的硬件上，外接干扰有可能会打乱程序执行顺序、更改RAM存储数据等等。

## 15.1 数学算数运算

### 【规则 15-1-1】除法运算，只检测除数为零就可靠吗

**说明：**

1. 除法运算前，检查除数是否为零几乎已经成为共识，但是仅检查除数是否为零就够了吗？
2. 考虑两个整数相除，对于一个signed long类型变量，它能表示的数值范围为：-2147483648 ~+2147483647，如果让-2147483648/ -1，那么结果应该是+2147483648，但是这个结果已经超出了signedlong所能表示的范围了。所以，在这种情况下，除了要检测除数是否为零外，还要检测除法是否溢出。

**执行级别：** **要求**

**正例：**

```c
#include <limits.h>
signed long sl1,sl2,result;
/*初始化sl1和sl2*/  
if ((sl2 == 0) || (sl1 == LONG_MIN && sl2 == -1)) 
{
    //处理错误  
}
else 
{
    result = sl1 / sl2;
}
```

**引用知识（官网，书籍等）：**《华为C语言编程规范》

### 【规则 15-1-2】检测运算溢出

**说明：**

1. 整数的加减乘运算都有可能发生溢出，在讨论未定义行为时，给出过一个有符号整形加法溢出判断代码
2. 嵌入式硬件一般没有浮点处理器，浮点数运算在嵌入式也比较少见并且溢出判断严重依赖C库支持，这里不讨论。

**执行级别：** **建议**

**正例：**

```c
#include <limits.h>  
unsigned int a,b,result;
/*初始化a，b*/
if (UINT_MAX - a < b) 
{
//处理溢出  
}
else 
{
    result = a + b;
}
```

**引用知识（官网，书籍等）：**《华为C语言编程规范》

### 【规则 15-1-3】检测移位

**说明：**
在讨论未定义行为时，提到有符号数右移、移位的数量是负值或者大于操作数的位数都是未定义行为，也提到不对有符号数进行位操作，但要检测移位的数量是否大于操作数的位数。下面给出一个无符号整数左移检测代码段：

**执行级别：** **建议**

**正例：**

```c
unsigned int ui1;
unsigned int ui2;
unsigned int uresult;
/*初始化ui1,ui2*/
if (ui2 > =sizeof(unsigned int) * CHAR_BIT) 
{
    //处理错误  
}
else 
{
    uresult = ui1 << ui2;
 }
```

**引用知识（官网，书籍等）：**《华为C语言编程规范》

### 【规则 15-2-1】具有形参的函数，需判断传递来的实参是否合法

**说明：**
程序员可能无意识的传递了错误参数；外界的强干扰可能将传递的参数修改掉，或者使用随机参数意外的调用函数，因此在执行函数主体前，需要先确定实参是否合法。

**执行级别：** **要求**

**正例：**

```c
int exam fun( unsigned char *str )
{
    if (str != NULL) 
    {// 检查“假设指针不为空”这个条件
        //正常处理代码
    }
    else 
    {
        //处理错误代码

    }
}
```

### 【规则 15-2-2】仔细检查函数的返回值

**说明：**
对函数返回的错误码，要进行全面仔细处理，必要时做错误记录。

**执行级别：** **要求**

```c
char *DoSomething(...) 
{
    char* p;
    p = malloc(1024);
    if (p == NULL) 
    { /*对函数返回值作出判断*/   
        UARTprintf(...);/*打印错误信息*/
        return NULL;
    }
    return p;
}
```

**引用知识（官网，书籍等）：**《华为C语言编程规范》

### 【规则 15-2-3】如果有硬件看门狗，则使用它。

**说明：**

1. 在其它一切措施都失效的情况下，看门狗可能是最后的防线。它的原理特别简单，但却能大大提高设备的可靠性。如果设备有硬件看门狗，一定要为它编写驱动程序。相关推荐:STM32实例-窗口看门狗实验。
2. 要尽可能早的开启看门狗，这是因为从上电复位结束到开启看门狗的这段时间内，设备有可能被干扰而跳过看门狗初始化程序，导致看门狗失效。尽可能早的开启看门狗，可以降低这种概率；
3. 不要在中断中喂狗，除非有其他联动措施。在中断程序喂狗，由于干扰的存在，程序可能一直处于中断之中，这样会导致看门狗失效。如果在主程序中设置标志位，中断程序喂狗时与这个标志位联合判断，也是允许的；
4. 喂狗间隔跟产品需求有关，并非特定的时间.产品的特性决定了喂狗间隔。对于不涉及安全性、实时性的设备，喂狗间隔比较宽松，但间隔时间不宜过长，否则被用户感知到，是影响用户体验的。对于设计安全性、有实时控制类的设备，原则是尽可能快的复位，否则会造成事故。

**执行级别：** **建议**

**反例：**

克莱门汀号在进行第二阶段的任务时，原本预订要从月球飞行到太空深处的Geographos小行星进行探勘，然而这艘太空探测器在飞向小行星时却由于一个软件缺陷而使其中断运作20分钟，不但未能到达小行星，也因为控制喷嘴燃烧了11分钟使电力供应降低，无法再透过远端控制探测器，最终结束这项任务，但也导致了资源与资金的浪费。

“克莱门汀太空任务失败这件事让我感到十分震惊，它其实可以透过硬件中一款简单的看门狗计时器避免掉这项意外，但由于当时的开发时间相当紧缩，程序设计人员没时间编写程序来启动它，”Ganssle说。

遗憾的是，1998年发射的近地号太空船(NEAR)也遇到了相同的问题。由于编程人员并未采纳建议，因此，当推进器减速器系统故障时，29公斤的储备燃料也随之报销──这同样是一个本来可经由看门狗定时器编程而避免的问题，同时也证明要从其他程序设计人员的错误中学习并不容易。

### 【规则 15-2-4】对非易失性存储器进行备份存储

**说明：**
非易失性存储器包括但不限于Flash、EEPROM、铁电。仅仅将写入非易失性存储器中的数据再读出校验是不够的。强干扰情况下可能导致非易失性存储器内的数据错误，在写非易失性存储器的期间系统掉电将导致数据丢失，因干扰导致程序跑飞到写非易失性存储器函数中，将导致数据存储紊乱。

一种可靠的办法是将非易失性存储器分成多个区，每个数据都将按照不同的形式写入到这些分区中，需要进行读取时，同时读出多份数据并进行表决，取相同数目较多的那个值。

**执行级别：** **建议**

**引用知识（官网，书籍等）：**《华为C语言编程规范》

### 【规则 15-2-5】软件锁

**说明：**
对于初始化序列或者有一定先后顺序的函数调用，为了保证调用顺序或者确保每个函数都被调用，我们可以使用环环相扣，实质上这也是一种软件锁。此外对于一些安全关键代码语句（是语句，而不是函数），可以给它们设置软件锁，只有持有特定钥匙的，才可以访问这些关键代码。也可以通俗的理解为，关键安全代码不能按照单一条件执行，要额外的多设置一个标志。

**执行级别：** **建议**

**示例：**

比如，向Flash写一个数据，我们会判断数据是否合法、写入的地址是否合法，计算要写入的扇区。之后调用写Flash子程序，在这个子程序中，判断扇区地址是否合法、数据长度是否合法，之后就要将数据写入Flash。

由于写Flash语句是安全关键代码，所以程序给这些语句上锁：必须具有正确的钥匙才可以写Flash。这样即使是程序跑飞到写Flash子程序，也能大大降低误写的风险。

```c
 /***************************************************************
 * 名称：RamToFlash() 
 * 功能：复制RAM的数据到FLASH，命令代码51。
 * 入口参数：dst        目标地址，即FLASH起始地址。以512字节为分界 
 *           src        源地址，即RAM地址。地址必须字对齐 
 *           no         复制字节个数，为512/1024/4096/8192 
 *           ProgStart  软件锁标志  
 * 出口参数：IAP返回值(paramout缓冲区) CMD_SUCCESS,SRC_ADDR_ERROR,DST_ADDR_ERROR, 
 SRC_ADDR_NOT_MAPPED,DST_ADDR_NOT_MAPPED,COUNT_ERROR,BUSY,未选择扇区 
 ****************************************************************/  
 void  RamToFlash(uint32 dst, uint32 src, uint32 no,uint8 ProgStart)  
 {
     PLC_ASSERT("Sector number",(dst>=0x00040000)&&(dst<=0x0007FFFF));
     PLC_ASSERT("Copy bytes number is 512",(no==512));
     PLC_ASSERT("ProgStart==0xA5",(ProgStart==0xA5));
     paramin[0] = IAP_RAMTOFLASH;       // 设置命令字  
     paramin[1] = dst;                  // 设置参数  
     paramin[2] = src;
     paramin[3] = no;
     paramin[4] = Fcclk/1000;
     if (ProgStart == 0xA5)                //只有软件锁标志正确时，才执行关键代码  
     {
         iap_entry(paramin, paramout);  // 调用IAP服务程序             
         ProgStart = 0;
     }
     else  
     {
         paramout[0]=PROG_UNSTART;
     }
 }
```

> 示例解析：该程序段是编程lpc1778内部Flash，其中调用IAP程序的函数iap_entry(paramin, paramout)是关键安全代码，所以在执行该代码前，先判断一个特定设置的安全锁标志ProgStart，只有这个标志符合设定值，才会执行编程Flash操作。如果因为意外程序跑飞到该函数，由于ProgStart标志不正确，是不会对Flash进行编程的

**引用知识（官网，书籍等）：**《华为C语言编程规范》

### 【规则 15-2-6】通信

**说明：**
通讯线上的数据误码相对严重，通讯线越长，所处的环境越恶劣，误码会越严重。抛开硬件和环境的作用，我们的软件应能识别错误的通讯数据。对此有一些应用措施：

1. 制定协议时，限制每帧的字节数；

每帧字节数越多，发生误码的可能性就越大，无效的数据也会越多。对此以太网规定每帧数据不大于1500字节，高可靠性的CAN收发器规定每帧数据不得多于8字节，对于RS485，基于RS485链路应用最广泛的Modbus协议一帧数据规定不超过256字节。因此，建议制定内部通讯协议时，使用RS485时规定每帧数据不超过256字节；

2. 使用多种校验

编写程序时应使能奇偶校验，每帧超过16字节的应用，建议至少编写CRC16校验程序。

3. 增加额外判断

增加缓冲区溢出判断。这是因为数据接收多是在中断中完成，编译器检测不出缓冲区是否溢出，需要手动检查，在上文介绍数据溢出一节中已经详细说明。

增加超时判断。当一帧数据接收到一半，长时间接收不到剩余数据，则认为这帧数据无效，重新开始接收。可选，跟不同的协议有关，但缓冲区溢出判断必须实现。这是因为对于需要帧头判断的协议，上位机可能发送完帧头后突然断电，重启后上位机是从新的帧开始发送的，但是下位机已经接收到了上次未发送完的帧头，所以上位机的这次帧头会被下位机当成正常数据接收。这有可能造成数据长度字段为一个很大的值，填满该长度的缓冲区需要相当多的数据（比如一帧可能1000字节），影响响应时间；另一方面，如果程序没有缓冲区溢出判断，那么缓冲区很可能溢出，后果是灾难性的。

4. 重传机制

如果检测到通讯数据发生了错误，则要有重传机制重新发送出错的帧。

**执行级别：** **建议**

**引用知识（官网，书籍等）：**《华为C语言编程规范》

### 【规则 15-2-7】使用卫语句

**说明：**

1. 卫语句就是把复杂的条件表达式拆分成多个条件表达式，减少嵌套。嵌套了好几层的if - then-else语句，转换为多个if语句，实现它的逻辑，这多条的if语句就是卫语句。
2. 卫语句将某些关键条件优先判断，简化程序流程走向。卫语句往往用于对 if 条件嵌套代码的优化。
3. 超过 3 层的 if-else 的逻辑判断代码可以使用卫语句、策略模式、状态模式等来实现，其中卫语句即代码逻辑先考虑失败、异常、中断、退出等直接返回的情况，以方法多个出口的方式，解决代码中判断分支嵌套的问题，这是逆向思维的体现。

**执行级别：** **建议**

**正例：**

```c
void func()  
{   
    if (IsWorkDay())  
    {  
        printf("Error,is work day");  
        return;  
    }  
    if (IsWorkTime())  
    {  
        printf("Error,is work time");  
        return;  
    }  
  
    rest();  
  
}  
```

> 正例解析：使用卫语句，清晰明了。

**反例：**

```c
void func(void)  
{  
    if (IsWorkDay())  
    {  
        printf("Error,is work day");  
    }  
    else  
    {  
        if (IsWorkTime())  
        {  
            printf("Error ,is work time");  
        }  
        else  
        {  
            rest();  
        }  
    }
}  
```

> 反例解析：嵌套的话语句很繁琐，可读性差。

**引用知识（官网，书籍等）：**《华为C语言编程规范》
