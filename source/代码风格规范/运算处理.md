# 9.1.运算处理

### 【规则 9-1-1】数组的使用必须保证不会出现越界

**说明：**
该准则的违背通常是下标超出了数组所指定的范围。

**执行级别：强制**

**正例：**

```
void func(void)
{
    int arr[4] = {1, 2, 3, 4};

    for (int i = 0; i < 4; i++)
    {
        printf("arr[%d] = %d\n", i, arr[i]);
    }
}
```

> 正例解析：数组下标在指定范围内

**反例：**

```
void func(void)
{
    int arr[4] = {1, 2, 3, 4};

    for (int i = 0; i < 5; i++)
    {
        printf("arr[%d] = %d\n", i, arr[i]);    //arr[4]时数组越界
    }
}
```

> 反例解析：循环到i=4时,会发生数组越界错误。

**来源（规范标准）:** 《GJB 5369-2005 航天型号软件C语言安全子集》

### 【规则 9-1-2】 禁止在非赋值表达式中出现赋值操作符

**说明：**
在非赋值表达式中出现赋值操作符，可能是将"=="误写为"="造成的，这会引起无法预料的后果，因此禁止在非赋值表达式中出现赋值操作符。

**执行级别：强制**

**正例：**

```
void func(void)
{
    int i = 0;

    /*...*/
    if (10 == i)     
    {
	    /*...*/
    }
}
```

> 正例解析：建议把常量写在==的左边

**反例：**

```
void func(void)
{
    bool i = 0;

    /*...*/
    if (i = 10) 
    {
	    /*...*/
    }
}
```

> 反例解析：将"=="误写为"=",部分编译器也能编译通过

**来源（规范标准）:** 《GJB 5369-2005 航天型号软件C语言安全子集》

### 【规则 9-1-3】 禁止对有符号类型进行移位运算

**说明：**
对于有符号数，移位操作再C语言标准中行为未定义，不同平台不一样，取决于编译器类型。无符号数统一按逻辑移位实现，行为确定。

**执行级别：强制**

**正例：**

```
void func(void)
{
    unsigned int a = 0;
    unsigned int b =1;
  
    a = b >> 1;        //只对无符号数进行移位操作
}
```

**反例：**

```
void func(void)
{
    int a = 0;
    int b = 1;
  
    a = b >> 1;     //不应对有符号数进行移位操作
}
```

> 反例解析：不应对有符号类型禁止移位运算

**来源（规范标准）:** 《GJB 5369-2005 航天型号软件C语言安全子集》

### 【规则 9-1-4】 对变量进行移位运算必须保证不会产生溢出

**说明：**
一些编译器不检查移位运算是否超出机器字长。

**执行级别：强制**

**正例：**

```
void static_p(void)     //32位运行环境
{
    UINT_32   x  = 0;
    UINT_32   y  = 0;
   
    /*...*/
    x = y << 28;
}
```

> 反例解析：移位运算在变量所占位数范围内

**反例：**

```
void static_p(void)      //32位运行环境
{
    UINT_32   x  = 0;
    UINT_32   y  = 0;
   
    /*...*/
    x = y << 34;
}
```

**反例：**

> 反例解析：移位运算超过了变量所占位数

**来源（规范标准）:** 《GJB 5369-2005 航天型号软件C语言安全子集》

### 【规则 9-1-5】 禁止给无符号变量赋负值

**说明：**
给无符号变量赋负值会导致不可预料的结果，这种情况不应该出现。

**执行级别：强制**

**反例：**

```
void func(void)
{
    unsigned char x = 0;

    /*...*/
    x = -1;
    printf("%d\n", x);    //输出255

    x = -2;
    printf("%d\n", x);    //输出254

    x = -3;
    printf("%d\n", x);    //输出253
}
```

> 反例解析：输出结果并非是我们想要的

**来源（规范标准）:** 《GJB 5369-2005 航天型号软件C语言安全子集》

### 【规则 9-1-6】 有符号类型的位长度必须大于等于两位

**说明：**
有符号类型只给一位的长度是没有意义的。

**执行级别：强制**

**正例：**

```
typedef struct
{
    int up:2;      //符号位占一bit位
    int down:2;
    int recv:4;
}VALUE_t;
```

**反例：**

```
typedef struct
{
    int up:1;    //符号位没位置存放
    int down:1;
    int recv:6;
}VALUE_t;
```

**来源（规范标准）:** 《GJB 5369-2005 航天型号软件C语言安全子集》

### 【规则 9-1-7】 位的定义必须是有符号整数或无符号整数

**说明：**
位不能定义为有符号或无符号整数之外的其它类型

**执行级别：强制**

**正例：**

```
typedef struct
{
    int up:2;
    int down:2;
    int rev:4;
}VALUE_t;
```

**反例：**

```
typedef struct
{
    float up:2;    //不能使用float类型
    float down:2;
    float rev:4;
}VALUE_t;
```

> 反例解析：位的定义不能为整数之外的其它类型,此处使用float类型不对

**来源（规范标准）:** 《GJB 5369-2005 航天型号软件C语言安全子集》

### 【规则 9-1-8】 赋值类型必须匹配

**说明：**
赋值类型不匹配会导致数据有效位的损失

**执行级别：强制**

**正例：**

```
void func(void)
{
    double f1 = 2.0f;
    double db1 = 3.000000111;
  
    /*...*/
    f1 = db1;
    printf("f1 = %.9f\n", f1);    //输出f1 = 3.000000111
    printf("db1 = %.9f", db1);    //输出db1 = 3.000000111
}
```

**反例：**

```
void func(void)
{
    float f1 = 2.0f;
    double db1 = 3.000000111;

    /*...*/
    f1 = db1;
    printf("f1 = %.9f\n", f1);    //输出f1 = 3.000000000
    printf("db1 = %.9f", db1);    //输出db1 = 3.000000111
}
```

> 反例解析: 精度丢失

**来源（规范标准）:** 《GJB 5369-2005 航天型号软件C语言安全子集》

### 【规则 9-1-9】 数组下标必须是大于等于零的整型数

**说明：**
数组下标表示数组元素的序号，所以数组下标必须是大于等于零的整型数

**执行级别：强制**

**正例：**

```
#define ArraySize 3

void func(void)
{
	int i = 0;
    int arr[ArraySize] = {0};
  
    /*...*/
	for(i = 0; i < ArraySize; i++)
}
```

**反例1：**

```
#define ArraySize 4.0f

void func(void)
{
    int arr[ArraySize] = {0};    //编译不过
  
    printf("%d", arr[3.5]);      //编译不过  
}
```

**反例2：**

```
void func(void)
{
	int arr[4] = {2, 3, 4, 5};

    printf("%d\n", arr[-1]);    //输出 0
}
```

> 反例解析：c语言中数组的下标可以是负号，在代码运行前不会对数组是否下标越界、溢出等异常进行警告或处理

**来源（规范标准）:** 《GJB 5369-2005 航天型号软件C语言安全子》

### 【规则 9-1-10】 禁止对常数值做逻辑非的运算

**说明：**
对常数值多逻辑非的运算会使用逻辑判别思路混乱

**执行级别：强制**

**正例：**

```
void func(void)
{
	bool succ = false;

	if (!succ)
	{
	    /*...*/
	}
}
```

**反例：**

```
void func(void)
{
	bool succ = false;

	if (succ == !1)
	{
	    /*...*/
	}
}
```

> 反例解析：逻辑非只对逻辑值的真假做非运算

**来源（规范标准）:** 《GJB 5369-2005 航天型号软件C语言安全子集》

### 【规则 9-1-11】 禁止对有符号类型使用位运算

**说明：**
位运算对有符号的数是很危险的，因为符号位会被错误的改变。

**执行级别：强制**

**正例：**

```
void func(void)
{
	unsigned int x = 1;

	x = x | 1;
	/*...*/
}
```

**反例：**

```
void func(void)
{
	int x = 1;

	x = x | 1;
	/*...*/
}
```

**来源（规范标准）:** 《GJB 5369-2005 航天型号软件C语言安全子集》

### 【规则 9-1-12】 变量的使用禁止超出所定义的范围

**说明：**
变量在运算过程中应确保不会发生超界的数据溢出，对安全关键变量必须要仔细进行值域检查

**执行级别：强制**

**正例：**

```
void func(void)
{
    UINT_8 x = 0;
  
    for (x = 0; x < 255; x++)
    {
    	/*...*/
    }
}
```

正例解析：x=255时退出for循环

**反例：**

```
void func(void)
{
    UINT_8 x = 0;
  
    for (x = 0; x < 512; x++)
    {
    	/*...*/
    }
}
```

> 反例解析：程序会在for中无限循环

**来源（规范标准）:** 《GJB 5369-2005 航天型号软件C语言安全子集》

### 【规则 9-1-13】禁止赋值操作符与"&&"或"||"连用

**说明：**
这是一种很不好的编程习惯，因为赋值被条件化了，原期望的赋值未必能被执行，因此禁止赋值操作符与"&&"或"||"连用

**执行级别：强制**

**正例：**

```
void func(void)
{
    bool flag = false;
    int x = 0;
	int y = 0;
  
    /*...*/
    x = y;
    if (flag && (x == 0))
    {
        /*...*/
    }
}
```

> 反例解析：先执行x = y, 在执行条件判断。

**反例：**

```
void func(void)
{
    bool flag = false;
    int x = 0; 
	int y = 0;
  
    /*...*/
    if (flag && ((x = y) == 0))
    {
        /*...*/
    }
}
```

> 反例解析：如果flag为真,则不会判断((x = y) == 0)，即不会执行x = y。

**来源（规范标准）:** 《GJB 5369-2005 航天型号软件C语言安全子集》

### 【规则 9-1-14】 表达式的值在任务求值顺序下应保持一致

**说明：**
由于C语言标准规定的只是运算符的结合顺序，而对于二元运算符的求值顺序未作定义，对于二元操作符，要先对两个操作数进行求值之后（但未指定求值顺序）再进行运算。因此上述两段程序的最终结果取决于编译器特性。

**执行级别：强制**

**正例：**

```
void func(void)
{
	int val = 0;
	int temp = 2;

	temp--;
	val = temp + temp;    //val = 2;
}
```

> 反例解析：先对temp进行自加或自减,再进行其它运算。

**反例：**

```
void func(void)
{
	int val = 0;
	int temp = 2;

	val = temp++ + --temp;    //不同的编译器可能计算出结果不一样
}
```

> 反例解析：如果编译器总是从左向右解析表达式, val=2+2=4; 如果编译器总是从右向左解析表达式，val=1+1=2;

**来源（规范标准）:** 《GJB 5369-2005 航天型号软件C语言安全子集》

### 【规则 9-1-15】 应避免除数可能为0的情况出现

**说明：**
被零除的错误 在进行除法运算时,如果不检查除数是否为零,则会导致一个运行时错误。为了避免这种情况发生,在进行除法运算前需要先检查除数是否为零。

**执行级别：强制**

**正例：**

```
void int func(int divisor)
{
	int devidend= 100;
	int quotient = 0;

	if(devisor == 0)
	{
	    printf("除数为0, 直接退出!\n");
	    return -1;
	}

	quotient = devidend / devisor;
	/*...*/
	return 0;
}
```

> 正例解析：对除数进行为0判断，并特殊处理

**反例：**

```
void int func(int divisor)
{
	int devidend= 100;
	int quotient = 0;

	quotient = devidend / devisor;
	/*...*/
	return 0;
}
```

> 反例解析：除数为0时会导致程序运行崩溃

**来源（规范标准）:** 《GJB 5369-2005 航天型号软件C语言安全子集》

### 【建议 9-1-1】 谨防长度操作符sizeof的副作用

**说明：**
长度操作符sizeof不计算操作数的值，所以对表达式做长度运算时可能会得出不可预料的结果

**执行级别：建议**

**正例：**

```
void func(void)
{
    int i = 0;
	int j = 0;

	j = 123;
    i = sizeof(j);
}
```

> 正例解析：先对j进行赋值，在将j所占空间大小传给i。

**反例：**

```
void func1(void)
{
    int i = 0;
	int j = 0;

    i = sizeof(j = 123);
}
```

> 反例解析：本意是先将123赋给j,再把j所占用的空间大小传给i。可是由于sizeof运算符只针对数据类型进行操作, 所以“i = sizeof(j = 123) ”实际上被替换成“i = sizeof(int32_t) ”。故表达式“j = 123”的操作不会进行,这就带来了可能的隐患。

**来源（规范标准）:** 《GJB 5369-2005 航天型号软件C语言安全子集》
