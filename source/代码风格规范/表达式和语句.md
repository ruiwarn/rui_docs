## 10.1 复合表达式

### 【建议 10-1-1】不要有多用途的复合表达式

**说明：**
表达式的用途尽可能单一。

**执行级别：建议**

**正例：**

```
int a = 0;
int b = 0;
int c = 0;
int d = 0;
int r = 0;

/*...*/
a = b + c;
d = a + r;
```

**反例:**

```
int a = 0;
int b = 0;
int c = 0;
int d = 0;
int r = 0;

/*...*/
d = (a = b + c) + r;
```

> 反例解析: 该表达式既求a值又求b值，应该拆分为两个独立的语句。

**引用知识（官网，书籍等）:** 林锐博士的《高质量C++/C编程指南》

### 【建议 10-1-2】不要编写太复杂的复合表达式

**说明：**
太复杂的表达式不易理解，且容易出错

**执行级别：建议**

**正例：**

```
/*...*/
i = a;
x = c + f;
y = g + h;

if ((i >= b) && (c < d) && (x <= y))
{
    /*...*/
}
```

**反例:**

```
/*...*/
if (i = a >= b && c < d && c + f <= g + h)
{
    /*...*/
}
```

> 反例解析: 表达式过于复杂

**引用知识（官网，书籍等）:** 林锐博士的《高质量C++/C编程指南》

### 【规则 10-1-1】不要把程序中的复合表达式与“真正的数学表达式”混淆

**说明：**
数学表达式不是C语言表达式。

**执行级别：强制**

**正例：**

```
int a = 0;
int b = 1;
int c = 2;

if ((a < b) && (b < c))
{
    /*...*/
}
```

**反例:**

```
int a = 0;
int b = 1;
int c = 2;

if (a < b < c)
{
    /*...*/
}
```

> 反例解析: a < b < c是数学表达式而不是程序表达式

**引用知识（官网，书籍等）:** 林锐博士的《高质量C++/C编程指南》

### 【原则 10-1-1】 把括号对一起写出

**说明：**
先写块的开始和结束部分，然后再填充中间部分。人们常常会抱怨说匹配括号对或者begin和end对很难，而这个问题是完全可以避免的。如果你遵循了这项指导原则，那么就再也不会为这些匹配工作而犯难了。

**执行级别：建议**

**正例：**

先这么写：

```
for (i = 0; i < maxLines; i++)
```

再这么写：

```
for (i = 0; i < maxLines; i++)
{

}
```

最后这么写：

```
for (i = 0; i < maxLines; i++)
{
    whatever goes in here ..
}
```

这种方法适用于所有的块结构，包含C++和Java中的if、for和while,以及Visual Basic中的If-Then-Else、For-Next和While-.Wend组合。

**引用知识（官网，书籍等）:** 《代码大全2》

### 【原则 10-1-2】 用括号来把条件表达清楚

**说明：**
要想读懂条件语句，就要先弄清楚哪条语句是跟在if判断后面的。在if判断后面只写一条语句可能看上去很美观，但是一经修改，这样的语句就会演变成复杂的块，而在这时用单一的语句就很容易引发错误。请用块来清楚地表达你的用意，无论块内的代码行数是1还是20。

**执行级别：建议**

**引用知识（官网，书籍等）:** 《代码大全2》

## 10.2. if 语句

### 【规则 10-2-1】 不可将布尔变量直接与TRUE、FALSE或者1、0进行比较

**说明：**
根据布尔类型的语义，零值为“假”（记为FALSE），任何非零值都是“真”（记为TRUE）。TRUE的值究竟是什么并没有统一的标准。例如Visual C++ 将TRUE定义为1，而Visual Basic则将TRUE定义为-1。

**执行级别：强制**

**正例：**

```
void func(void)
{
    bool succ = false;

    /*...*/
    if (!succ)
    {
        /*...*/
    }
}
```

**反例：**

```
void func(void)
{
    bool succ = false;

    /*...*/
    if (succ == 0)
    {
        /*...*/
    }
}
```

> 反例解析: 不可将布尔变量直接与0或1比较

**引用知识（官网，书籍等）:** 林锐博士的《高质量C++/C编程指南》

### 【规则 10-2-2】 整型变量与零值比较时，应将整型变量用"=="或"!="直接与0比较

**执行级别：强制**

**正例：**

```
void func(void)
{
    int value = 0;

    /*...*/
    if (value == 0)
    {
        /*...*/
    }
}
```

**反例：**

```
void func(void)
{
    int value = 0;

    /*...*/
    if (!value)    //会让人误解value是布尔变量
    {
        /*...*/
    }
}
```

**引用知识（官网，书籍等）:** 林锐博士的《高质量C++/C编程指南》

### 【规则 10-2-3】 浮点变量与零值比较时，不可将浮点变量用“==”或“！=”与任何数字比较

**说明：**

无论是float还是double类型的变量，都有精度限制。一定要避免将浮点变量用“==”或“！=”与数字比较，应该设法转化成“>=”或“<=”形式

**执行级别：强制**

**正例：**

```
const float EPSINON = 0.00001

void func(void)
{
    float x = 0.0f;

    if ((x >= -EPSINON) && (x <= EPSINON))
    {
        /*...*/
    }
}
```

**反例：**

```
void func(void)
{
    float x = 0.0f;
  
    if(x == 0.0)
    {
    	/*...*/
    }
}
```

**引用知识（官网，书籍等）:** 林锐博士的《高质量C++/C编程指南》

### 【规则 10-2-4】 指针变量与零值比较时，应将指针变量用"=="或"!="与NULL比较

**说明：**

指针变量的零值是“空”（记为NULL）。尽管NULL的值与0相同，但是两者意义不同

**执行级别：强制**

**正例：**

```
char *p = NULL;

/*...*/
if (p != NULL)
{
    /*...*/
}

```

**反例1：**

```
char *p = NULL;

/*...*/
if (p != 0)     // 容易让人误解p是整型变量
{
    /*...*/
}
```

**反例2：**

```
char *p = NULL;

/*...*/
if (p)          // 容易让人误解p是布尔变量
{
    /*...*/
}
```

**引用知识（官网，书籍等）:** 林锐博士的《高质量C++/C编程指南》

### 【原则 10-2-1】 首先写正常代码路径，再处理不常见的情况

**说明：**
写代码的时候应该把你认为最希望的情况写在最前面，而不是一上来就处理诸如用户非法输入之类的不常见情况。确认那些不常见的情况不会遮掩正常的执行路径，这对可读性和代码性能来说都很重要。

**执行级别：建议**

**引用知识（官网，书籍等）:** 《代码大全2》

### 【原则 10-2-2】 确保对于等量的分支是正确的

**说明：**
尽量使用">="和"<=" 而不是"<"和">"，原因很简单，因为后者更容易犯下偏差一(off-by-one)错误。在条件语句里，也要仔细考虑条件是否同实际情况相符合，避免犯同样的错误。

**执行级别：强制**

**引用知识（官网，书籍等）:** 《代码大全2》

### 【原则 10-2-3】 把正常情况的处理放在if后面而不要放在else后面

**说明：**
把你认为会正常出现的情况放在前面来处理。这符合把决策的结果代码放在尽可能靠近决策位置的一般原则。

**执行级别：强制**

**引用知识（官网，书籍等）:** 《代码大全 2》

### 【原则 10-2-4】 让if子句后面跟随一个有意义的语句

**说明：**
去除无意义的语句和代码行
**执行级别：强制**

**正例：**

```
if (!someTest)
{
    //do something
    ...
}
```

**反例：**

```
if (someTest)
{
    ;
}
else
{
    //do something
    ...  
}
```

> 反例解析：if语句是空的，且多了额外的空语句行和else代码行

**引用知识（官网，书籍等）:** 《代码大全 2》

### 【原则 10-2-5】 考虑else子句

**说明：**
如果你认为自己只需要一个简单的f语句，那么请考虑你是否真的不需要一个if-then-else语句。通用汽车公司做的一项经典分析发现，有5至8成的if语句都应该配有一个else子句。

**执行级别：建议**

**正例：**

```
if (!someTest)
{
    ;
}
else
{
    //do something
    ...  
}

```

**引用知识（官网，书籍等）:** 《代码大全 2》

### 【原则 10-2-6】 测试else子句的正确性

**说明：**
在测试代码的时候，你可能会认为只有主子句(即if子句)需要测试。然而如果有可能测试else子句的话，也一定要测试它。

**执行级别：强制**

**引用知识（官网，书籍等）:** 《代码大全 2》

### 【原则 10-2-7】 检查if和else子句是不是弄反了

**说明：**
在编程中常常会犯这么一种错误，那就是要么把本应放在if子句后面的代码和本应放在else子句后面的代码给弄反了，要么就把if测试的逻辑弄反了。请检查你的代码中有没有这种常见错误。

**执行级别：强制**

**引用知识（官网，书籍等）:** 《代码大全 2》

### 【原则 10-2-8】 利用布尔函数调用简化复杂的检测

**说明：**

**执行级别：建议**

**正例：**

```
if (IsControl(inputCharacter))
{
    characterType CharacterType_ControlCharacter;
}
else if (IsPunctuation(inputCharacter ))
{
    characterType CharacterType_Punctuation;
}
else if (IsDigit(inputCharacter))
{
    characterType CharacterType_Digit;
}
else if (IsLetter(inputCharacter))
{
    characterType CharacterType_Letter;
}
```

**引用知识（官网，书籍等）:** 《代码大全 2》

### 【原则 10-2-9】 确保所有的情况都考虑到了

**说明：**
写一个放在最后的els子句，用出错消息或者断言来捕捉那些你不考虑的情况。这种消息是给你而不是给最终用户看的，因此请适当地措辞。

**执行级别：建议**

**正例：**

```
if ( IsLetter(inputCharacter ))
{
    characterType CharacterType Letter;
}
else if ( IsPunctuation(inputCharacter ))
{
    characterType CharacterType_Punctuation;
}
else if(IsDigit(inputCharacter ))
{
    characterType CharacterType_Digit;
}
else if ( IsControl(inputCharacter))
{
    characterType CharacterType_ControlCharacter;
}
else
{
    DisplayInternalError("Unexpected type of character detected.");
}

```

**引用知识（官网，书籍等）:** 《代码大全 2》

## 10.3.循环语句的效率

### 【建议 10-3-1】 在多重循环中，如果有可能，应当将最长的循环放在最内层，最短的循环放在最外层，以减少CPU跨切循环层的次数

**说明：**

C++/C循环语句中，for语句使用频率最高，while语句其次，do语句很少用。本节重点论述循环体的效率。提高循环体效率的基本办法是降低循环体的复杂性

**执行级别：建议**

**正例：**

```
for (col = 0; col < 5; col++ )
{
    for (row = 0; row < 100; row++)
    {
        sum = sum + a[row][col];
    }
}
```

**反例：**

```
for (row = 0; row < 100; row++)
{
    for ( col = 0; col < 5; col++ )
    {
        sum = sum + a[row][col];
    }
}
```

**引用知识（官网，书籍等）:** 林锐博士的《高质量C++/C编程指南》

### 【建议 10-3-2】 如果循环体内存在逻辑判断，并且循环次数很大，宜将逻辑判断移到循环体的外面

**说明：**

**执行级别：建议**

**正例：**

```
for (i = 0; i < N; i++)
{
    if (condition)
        DoSomething();
    else
        DoOtherthing();
}
```

**反例：**

```
if (condition)
{
    for (i = 0; i < N; i++)
        DoSomething();
}
else
{
    for (i = 0; i < N; i++)
        DoOtherthing();
}
```

**引用知识（官网，书籍等）:** 林锐博士的《高质量C++/C编程指南》

## 10.4 for语句的循环控制变量

### 【原则 10-4-1】 不要为了终止循环而胡乱改动for循环的下标。

**说明：**
有些程序员会随便改动for循环下标的取值，以达到提前终端循环的目的。

**执行级别：强制**

**反例：**

```
for (int i = 0; i < 100; i++)
{
    /*...*/
    if ( ... )
    {
        i = 100;
    }
}
```

> 反例解析: 在某些条件下把i赋值100来终止循环,事实上，所有好的程序员都会避免这么做，这是业余爱好者的标志。一旦你写好了for循环，那么它的循环计数器就不受你的控制了。建议使用while循环来获得对退出条件更多的控制权。

**引用知识（官网，书籍等）:** 《代码大全 2》

### 【原则 10-4-2】 避免出现依赖于循环下标最终取值的代码

**说明：**
在循环终止后使用循环下标值是很不好的。循环下标的最终取值根据语言以及实现的不同而不同。循环终止正常与否也会影响到这一数值。即使你恰好能不暇思索地知道这一取值是多少，那么下一个阅读代码的人也会在上面花费时间。更好并且更具自我描述性的做法是，在循环体内某个适当的地方把这一最终取值赋给某个变量。

**执行级别：强制**

**正例：**

```
bool found = false;

for (recordCount = 0; recordCount < MAX_RECORDS; recordCount++)
{
    if (encry[recordCount] == testValue)
    {
        found = true;
        break;
    }
}

return found;
```

> 正例解析：多用一个布尔变量使最终代码变得更加清晰。

**反例：**

```
for (recordCount = 0; recordCount < MAX_RECORDS; recordCount++)
{
    if (encry[recordCount] == testValue)
    {
        break;
    }
}

if (recordCount < MAX_RECORDS)
{
    return true;
}
else
{
    return false;
}
```

> 反例解析: if(recordCount < MAX_RECORDS)检测会让人觉得该循环将会处理完encry[]中的所有值，如果发现与testValue相同的取值就返回true,否则返回false。然而很难记住下标值是不是一直递增到超出循环的末尾，因此很容易犯off-by-one错误。最好还是不要写出依赖于下标最终值的代码。

**来源（规范标准）:** 《代码大全 2》

### 【建议 10-4-1】 建议for语句的循环控制变量的取值采用“半开半闭区间”写法

**说明：**
从功能上看，虽然半开半闭区间写法和闭区间写法的功能是完全相同的，但相比之下，半开半闭区间写法更能够直观地表达意思，具有更高的可读性。

**执行级别：建议**

**正例：**

```
for (int x = 0; x < N; x++)
{
    /*...*/
}
```

**反例：**

```
for (int x = 0; x <= N - 1; x++)
{
    /*...*/
}
```

**来源（规范标准）:** 林锐博士的《高质量C++/C编程指南》

## 10.5 switch语句

### 【建议 10-5-1】每个case语句的结尾不要忘了加break，否则将导致多个分支重叠（除非有意使多个分支重叠）。

**说明：**
这种习惯很不好，因为它把不同的控制结构搅在一起了。嵌套的控制结构已经够难理解的了，重叠的结构简直就不可能弄清楚。修改case'A'或者case 'B'。比做脑部外科手术还困难，而且很有可能需要先清理一下这些情况后才能做任何修改。这样倒不如一开始就做对的好。总之，避免代码执行路径越过case子句的末尾是个好主意。如果你要故意让代码越过某一cse子句的末尾，那么就在相应的位置给出明确的注释，解释为什么要这样编写代码。

**执行级别：建议**

**正例：**

```
void func(int val)
{
	switch(val)
	{
	    case 0:        //注释表明为什么没用break
            ...
	    case 1:
            ...
	        break;
	    default:
        	break;
	}

	/*...*/
}

```

**来源（规范标准）:** 《代码大全 2》

### 【建议 10-5-2】不要忘记最后那个default分支。

**说明：**

如果 switch语句中缺省了default语句，当所有的case语句的表达式值都不匹配时，则会条转到整个switch语句后的下一个语句执行。加入default语句会体现事先已有所考虑单位编程思想

**执行级别：建议**

**正例：**

```
void func(int val)
{
	int x = 0;
    int y = 0;

	switch (val)
	{
	    case 0:
	        x = val;
	        break;
	    case 1:
	        y = val;
	        break;
	    default:
        	break;
	}

	/*...*/
}
```

**反例：**

```
void func(int val)
{
	int x = 0, y = 0;

	switch(val)
	{
	    case 0:
	        x = val;
	        break;
	    case 1:
	        y = val;
	        break;
	}

	/*...*/
}
```

**来源（规范标准）:** 林锐博士的《高质量C++/C编程指南》

### 【原则 10-5-1】 简化每种情况对应的操作

**说明：**
使得与每种情况相关的代码短小精悍。简短的情况处理代码会使case语句的结构更加清晰。如果某种情况执行的操作非常复杂，那么就写一个子程序，并在该情况对应的case子句中调用它，而不要把代码本身放进这一case子句里。

**执行级别：建议**

**来源（规范标准）:** 《代码大全 2》

### 【原则 10-5-2】 不要为了使用case语句而刻意制造一个变量

**说明：**
case语句应该用于处理简单的、容易分类的数据。如果你的数据并不简单，那么就使用if-then-else语句串。为使用case而刻意构造出的变量很容易把人搞糊涂，你应该避免使用这种变量。

**执行级别：建议**

**来源（规范标准）:** 《代码大全 2》

### 【原则 10-5-3】 把default子句只用于检查真正的默认情况

**说明：**
也许有时候你只剩下了一种情况需要处理，于是就决定把这种情况编写为default子句（默认子句）。尽管这么做有时候很诱人，但却是很不明智的。你将失去case语句的标号(label)所提供的自动说明功能，而且也丧失了使用default子句检测错误的能力。这种case语句一经修改很容易损坏。如果你用的是真正的默认情况，那么增加一种新情况就很容易一你只需增加这种情况和相应的代码即可。但如果你所用的是伪造的默认情况，那么修改起来就会非常困难。你不得不增加新的情况，很可能还要把它变为新的默认情况，然后把原来用的默认情况改为普通情况。还是一开始就使用真正的默认情况吧。

**执行级别：建议**

**来源（规范标准）:** 《代码大全 2》

### 【原则 10-5-4】 利用default子句来检测错误

**说明：**
如果一条case语句中的默认子句既没有用来做其他的处理，按照正常执行顺序也不太可能会发生，那么就向里面加入一条诊断消息。

**执行级别：建议**

**来源（规范标准）:** 《代码大全 2》

## 10.6 goto语句

### 【建议 10-6-1】少用、慎用goto语句，不是禁用

**说明：**
 C语言中提供了可以随意“滥用”的 goto语句和标记跳转的标号。从理论上 goto语句是没有必要的，实践中没有goto语句也可以很容易的写出代码，但是某些场合下goto语句还是用得着的，最常见的用法就是终止程序在某些深度嵌套的结构的处理过程

**执行级别：建议**

**正例:**

```
for (...)
{
    for (...)
    {
        for (...)
        {
            if (disaster)
            {
                goto error;
            }
        }
    }
}
error:
    ...
```

**来源（规范标准）:** 林锐博士的《高质量C++/C编程指南》

### 【原则 10-6-1】goto使用原则总结

**说明：**

1. 在那些不直接支持结构化控制语句的语言里，用goto去模拟那些控制结构。在做这些的时候，应该准确地模拟。不要滥用goto所带来的灵活性。
2. 如果语言内置了等价的控制结构，那么就不要用goto。
3. 如果是为提高代码效率而使用goto,请衡量此举实际带来的性能提升。在大多数情况下，你都可以不用goto而重新编写代码，这样既可以改善可读性，同时也不会损失效率。如果你的情况比较特殊，那么就对效率的提升做出说明，这   样，goto的反对者们在看见goto以后就不会删除它。
4. 除非你要模拟结构化语句，否则尽量让每个子程序内只使用一个goto标号。
5. 除非你要模拟结构化语句，否则尽量让goto向前跳转而不要向后跳转。
6. 确认所有的goto标号都被用到了。没用到的goto标号表明缺少了代码，即缺少了跳向该标号的代码。如果某些标号没有用，那么久删掉它们。
7. 确认goto不会产生某些执行不到的代码
8. 对某一个goto用法所展开的争论并不是事关全局的。如果程序员知道存在替换方案，并且也愿意为使用goto辩解，那么用goto也无妨。

**来源（规范标准）:** 《代码大全2》

## 10.7.语句使用

### 【规则 10-7-1】使用的八进制数必须加以注释

**说明：**

由于八进制数是以0开始的，容易与十进制的数混淆。

**执行级别：强制**

**正例：**

```
void func(void)
{
    unsigned int i = 0;
  
    i = (unsigned int)012;     //12为八进制
    printf("i = %d\n", i);
}
```

**反例：**

```
void func(void)
{
    unsigned int i = 0;
  
    i = (unsigned int)012;
    printf("i = %d\n", i);    //输出i = 8
}
```

**来源（规范标准）:** 《GJB 5369-2005 航天型号软件C语言安全子集》

### 【原则 10-7-1】在循环开始处用continue进行判断

**说明：**
开始处做完条件判断后让代码越过剩下的循环体继续执行。例如，如果在循环中要阅读记录、忽略掉一种记录而处理另一种，那么你就可以在循环开始处加入这种判断

**执行级别：强制**

**正例：**
伪代码示例：相对安全地使用continue

```
while (not eof(file)) do
    read(record, file )
    if (record.Type <> targetType) then
        continue
    -- process record of targetType
    ...
end while
```

这样使用continue, 可以避免用一个能让整个循环体都缩进的f判断。反之，如果continue出现在循环中部或者末尾，那么就应该改用if。

**来源（规范标准）:** 《代码大全2》

### 【原则 10-7-2 】使用break和continue时要小心谨慎

**说明：**
使用break消除了把循环看做黑盒子的可能性。把控制循环退出的条件只写在一条语句里是简化循环的有力手段。使用break就使阅读代码的人必须去读循环体，才能理解循环是如何控制的。这使循环变得更难理解。除非你已经考虑过各种替换方案，否则不要使用break。我们无法确定continue和break是好还是坏。有些计算机科学家认为它们是结构化编程中的合法技巧，有些人却不这么认为。既然你不能对continue和break究竟是对是错做出普遍意义下的判断，那么就用吧，但是前提是对由此可能产生的错误保持警惕。其实这里的建议很简单：如果你不能证明使用break或者continue的正当性，那么就不要用它们。

**执行级别：建议**

**来源（规范标准）:** 《代码大全2》

### 【建议 10-7-1】谨慎使用寄存器变量

**说明：**
寄存器变量的使用可能会产生不可预料的结果，应谨慎使用。寄存器变量，只是建议编译器使用寄存器，并不是一定要使用寄存器，变量类型需要CPU的支持。
（1）C编译程序会自动地将寄存器变量变为自动变量。
（2）由于受硬件寄存器长度的限制，所以寄存器变量只能是char、int或指针型。寄存器说明符只能用于说明函数中的变量和函数中的形参，因此不允许将外部变量或静态变量说明为"register"。
（3）register变量使用的是硬件CPU中的寄存器，寄存器变量无地址，所以不能使用取地址运算符"&"求寄存器变量的地址。

**执行级别：建议**

**正例：**

```
void static_p(void)                                                   
{                                                                    
    register SINT_32  i= 0；                                           
    ／*...*／                                                  
} 
```

**来源（规范标准）:** 《GJB 5369-2005 航天型号软件C语言安全子集》
