# 13.1.程序效率

### 【规则 13-1-1】 应保证循环体内工作量最小化。

**说明：**
将不依赖于循环变量的任何计算或操作移至循环外部。这将防止在每次循环迭代中执行不必要的计算。

**执行级别：** **要求**

**正例：**

```c
for (ind = 0 ; ind < MAX_ADD_NUMBER; ind++)
{
    sum += ind;
}
backSum = sum;
```

> 正例解释：

**反例：**

```c
for (ind = 0 ; ind < MAX_ADD_NUMBER; ind++)
{
    sum += ind;
    backSum = sum;
}
```

> 反例解释：`backSum = sum`为不依赖于循环变量，不应该仿放在循环内部，影响程序效率。

**引用知识（官网，书籍等）：**

**来源（规范标准）：** 《GB/T 28169-2011 嵌入式软件 C语言编码规范》

### 【规则 13-1-2】 在多重循环中，应将循环次数多的循环放在内层。

**说明：**
减少CPU切入循环层的次数。

**执行级别：** **建议**

**正例：**

```c
for (i = 0 ; i < 8; i++)
{
    for (j = 0; j < 200; j++)
    {
        total += val[j][i];
    }
}
```

> 正例解释：

**反例：**

```c
for (i = 0 ; i < 200; i++)
{
    for (j = 0; j < 8; j++)
    {
        total += val[j][i];
    }
}
```

> 反例解释：

**引用知识（官网，书籍等）：**

**来源（规范标准）：** 《GB/T 28169-2011 嵌入式软件 C语言编码规范》

### 【规则 13-1-3】 循环体内不宜包含判断语句。

**说明：**
目的是减少判断次数，循环体内的判断语句是否可以移到循环体外要视具体情况而定。在一般情况下，与循环变量无关的判断语句可以放到循环体外。

**执行级别：** **建议**

**正例：**

```c
for (int i = 0; i < 10; i += 2) 
{
    printf("%d is even\n", i);
    printf("%d is odd\n", i + 1);
}
```

> 正例解释：将循环变量 `i`的步长设置为2，从而使循环体内不再需要判断 `i`的奇偶性。这样可以减少循环体内的工作量，从而提高代码的效率。

**反例：**

```c
for (int i = 0; i < 10; i++) {
    if (i % 2 == 0)
    {
        printf("%d is even\n", i);
    } 
    else 
    {
        printf("%d is odd\n", i);
    }
}
```

> 反例解释：循环体内包含了一个判断语句，用于判断循环变量i的奇偶性。由于这个判断语句在每次循环迭代中都会执行，因此会导致循环体内的工作量增加，从而影响代码的效率

**引用知识（官网，书籍等）：**

**来源（规范标准）：** 《GB/T 28169-2011 嵌入式软件 C语言编码规范》

#### 【建议 13-1-1】 应注意switch-case语句的使用。

**说明：**
为了提高程序效率，应把switch-case语句中的每一种具体情况按照他们发生的相对频率排序，即把最可能发生的情况放在最前面，最不可能发生的情况放在最后面。

**执行级别：** **建议**

**引用知识（官网，书籍等）：**

**来源（规范标准）：** 《GB/T 28169-2011 嵌入式软件 C语言编码规范》

### 【建议 13-1-2】 应避免使用标准库。

**说明：**
很多大的库例程设法处理所有可能的情况，占用了庞大的内存空间，因此嵌入式系统编程应尽可能的减少使用标准库函数。

**执行级别：** **建议**

**引用知识（官网，书籍等）：**

**来源（规范标准）：** 《GB/T 28169-2011 嵌入式软件 C语言编码规范》

### 【建议 13-1-3】 选择合适的算法和数据结构。

**说明：**
选择一种合适的数据结构很重要，如果在一堆随机存放的数中使用了大量的插入和删除指令那使用链表要快得多。数组与指针语句具有十分密切的关系，一般来说，指针比较灵活简洁，而数组则比较直观，容易理解。对于大部分的编译器，使用指针比使用数组生成的代码更短，执行效率更高。在许多种情况下，可以用指针运算代替数组索引，这样做常常能产生又快又短的代码。与数组索引相比，指针一般能使代码速度更快，占用空间更少。

**执行级别：** **建议**

**正例：**

```c
for ( ; ; )
{
   total += array[i++];
}
```

> 正例解释：

**反例：**

```c
p = array;
for ( ; ; )
{
   total += *(p++);
}
```

> 反例解释：

**引用知识（官网，书籍等）：** 林锐博士的《高质量C++/C编程指南》

### 【建议 13-1-4】 代码尽量简洁，避免重复。

**说明：**
代码重复率太高了，不仅占用过多的类存，而且执行效率差可读性差。

**执行级别：** **建议**

**正例：**

```c
for (i = 0 ; i < 5 ; i++)
{
    Sum += 5;
}
```

> 正例解释：

**反例：**

```c
Sum += 5;
Sum += 5;
Sum += 5;
Sum += 5;
Sum += 5;
```

> 反例解释：代码重复，占用行数多。

**引用知识（官网，书籍等）：** 林锐博士的《高质量C++/C编程指南》

### 【建议 13-1-5】 合理使用宏定义。

**说明：**
函数调用需要一 些CPU时间，而宏不存在这个问题，宏仅仅作为预先写好的代码嵌入到当前程序，不会产生函数调用，所以仅仅是占用了空间，在频繁调用同一个宏的时候，该现象尤其突出。

**执行级别：** **建议**

**引用知识（官网，书籍等）：** 林锐博士的《高质量C++/C编程指南》
