# 事件记录部分设计说明
## 事件记录需求
目前根据698标准协议和山东扩展协议，整理出来的事件记录有以下几个：
- 窃电事件
- 超差事件
- 电表清零事件
- 事件清零事件
- 编程事件
- 电压不平衡事件
- 电流不平衡事件
- 断路器告警事件
- 保护动作事件
- 闸位变化事件
- 保护功能投退事件
- 温度超限事件
- 跳闸事件
- 合闸事件
- A、B、C相欠压事件
- A、B、B相过压事件
- A、B、B相失压事件
- A、B、C相断相事件
- A、B、C相过流事件
- A、B、B相过载事件
- A、B、B相功率因数超下限事件
- 电压逆相序事件
- 电流逆相序事件
- 电流严重不平衡事件
- 有功组合方式编程事件
- 无功组合方式编程事件
- 掉电事件
## 类的设计
首先根据698标准协议文档，事件记录类是如下格式：

![image](http://172.17.0.100:8080/wangrui/lc_manage_project_new/-/raw/master/doc/figures/46.png?inline=false)

因此，主站的访问需求就是这11个属性和4个方法，其中方法1意思是清楚某一事件记录对象的记录，方法2为执行一次事件记录。
因此，我们设计通用类如下所示：
```C
//事件对象类
CLASS(EventClass)
{
//属性1 逻辑名
    const uint16_t name;    //OI逻辑名
    /* 不在此定义数据类型,读取时直接访问eeprom */
//属性2 事件记录表
//属性3 关联对象属性表
//属性4 当前记录数
//属性5 最大记录数
//属性6 配置参数
//属性7 当前值记录表
    uint32_t sum_time;
//属性8 上报标识
//   uint8_t report_id;
//属性9 有效标识
//属性10 时间状态记录表
//属性11 上报方式∷=enum 主动上报(0), 跟随上报(1)
//    uint8_t report_method;
//属性12 自增加属性,用于储存索引信息,该属性将储存与eeprom中
    event_manage_t manage;
//方法1 获取属性值
    uint8_t (*const get)(EventClass * const, uint8_t attr, uint8_t index, uint8_t *const destin, uint16_t *const out_len); //获取index的属性值并放入destin中,并返回放入的长度,大端放入目标buf
//方法2 设置属性值
    uint8_t (*const set)(EventClass * const, uint8_t attr, uint8_t index, const uint8_t *const source, uint16_t n); /* 返回698标准错误码,大端写入 */
//方法3 记录性特有访问方法
    uint8_t (*const get_record)(EventClass * const, uint8_t attr, class_rsd_t *rsd, class_rcsd_t *rcsd, uint8_t *const destin, uint16_t *const out_len); /* 返回698标准错误码,大端写入 */
//方法4 操作
    uint8_t (*const action)(EventClass * const, uint8_t method, const uint8_t *const param, uint16_t n); /* 0成功,1失败 */
//方法5 自我修复功能
    void (*const self_repair)(EventClass * const);
};
```
除了属性1和自增加属性12需要在对象中分配变量空间外，其他的属性在读取\设置中均直接操作eeprom或者表内参数。其中方法1，为获取某个属性值，大部分的需求是访问属性2，因此通过get接口可以从flash访问到事件记录；方法2为设置属性，主站可能会配置属性6、8、9、11等属性;方法3为通过行、列筛选器访问事件记录的接口;方法4为事件清零、触发事件、增加事件记录储存对象的接口。
## 储存设计
当主站调用方法1或者方法3进行事件记录读取时，我们需要从flash和eeprom读出来该事件对象的fhlas储存记录返回给主站，或者我们自己调用方法4根据某种条件触发事件记录时需要将该次记录写入flash和eeprom，因此我们重点看一下属性12通用性储存设计，属性12如下图：
```C
/**
 * @brief 事件管理信息,用户维护事件记录对象
 *
 */
typedef struct
{
    uint32_t eeprom_addr;           /* eeprom只有2字节,为了对齐因此使用4字节 */
    uint32_t num_count;             /* 事件发生的总次数,发生过并且结束过才算一次 */
    uint32_t time_sum;              /* 事件发生的累计时间 */
    uint32_t next_write_addr;       /* 最新的一次数据写地址 */
    uint32_t flash_start_addr;      /* 分配的flash扇区起始地址 */
    uint16_t flash_one_record_size; /* 单条事件记录分配的flash大小(byte) */
    uint16_t flash_max_page;        /* 分配的flash扇区页数(page) */
    event_form_t oad[34];           /* 关联对象属性表, 默认+扩展最多允许34个 */
    uint16_t current_record_number; /* 当前记录数 */
    uint8_t number_new;             /* 新增次数 */
    bool event_start_flag;          /* 事件发生标志 */
    bool event_end_flag;            /* 事件结束标志 */
    event_report_identify_t report_id; /* 上报标识 */
    event_report_method_t report_method;          /* 上报方法 */
    uint8_t res[3];
    uint16_t cs;
} event_manage_t;
```
该结构体将存入eeprom，每一个事件记录实例对象都具有一个这样的通用属性，通过这个属性，可以对flash进行读、写等操作。比较重要的是第7个变量“oad”关联对象属性表，咱们事件记录触发后要存哪些东西都是靠这个变量来维护的，该变量类型如下：
```C
/**
 * @brief 事件关联属性表定义
 *
 */
typedef struct
{
    uint32_t oad; /* 要储存的oad */
    uint16_t len; /* 该数据项的长度 */
    uint16_t res; /* 对齐预留 */
} event_form_t;
```
也就是说，在系统首次上电的时候，我们将在eeprom中储存一些默认的关联对象，储存类型就是上面的结构体类型，有oad、数据类型、数据长度3个关键属性。
举例我们暂时的需求是
- 窃电事件
- 清零事件
- 事件清零事件
- 编程事件

因此，我们的表里面就有这5个具体的实例对象，那么每一个对象在构造的时候首先要从eeprom把自己的属性12读出来，因此我们先划分5个eeprom空间，具体的实例对象还有自己的flash空间，eeprom空间和flash划分如下：
```C
/* 698窃电事件空间规划 */
#define  FLASH_698_EVENT_STEAL_ADDR            (FLASH_FREEZE_START_ADDR_FR_HOUR+FLASH_FREEZE_HOUR_USED_PAGE*FLASH_PAGE_SIZE)  //起始地址
#define  FLASH_698_EVENT_STEAL_PAGE            (16U*2U)  //使用2个扇区

/* 698电表清零事件空间规划 */
#define  FLASH_698_EVENT_CLEAN_ADDR            (FLASH_698_EVENT_OVER_ERR_ADDR+FLASH_698_EVENT_OVER_ERR_PAGE*FLASH_PAGE_SIZE)  //起始地址
#define  FLASH_698_EVENT_CLEAN_PAGE            (16U*2U)  //使用2个扇区

/* 698事件事件清零空间规划 */
#define  FLASH_698_EVENT_EVENT_CLEAR_ADDR      (FLASH_698_EVENT_CLEAN_ADDR+FLASH_698_EVENT_CLEAN_PAGE*FLASH_PAGE_SIZE)  //起始地址
#define  FLASH_698_EVENT_EVENT_ADDR_PAGE       (16U*2U)  //使用2个扇区

/* 698编程事件空间规划 */
#define  FLASH_698_EVENT_PROGRAM_ADDR          (FLASH_698_EVENT_EVENT_CLEAR_ADDR+FLASH_698_EVENT_EVENT_ADDR_PAGE*FLASH_PAGE_SIZE)  //起始地址
#define  FLASH_698_EVENT_PROGRAM_PAGE          (16U*2U)  //使用2个扇区
```
具体的eeprom地址和flash地址、页信息都已在属性12中，因此，不管有多少个对象，访问、操作的方法都是通用的，访问的时候自己从属性12中拿eeprom、flash信息就行。
## 构造函数设计
在首次上电或者复位的时候，构造函数会被调用，用于给每个对象填入有效值，而事件记录部分主要就是通过eeprom将属性12的值进行填充，而复位的时候属性12里面都是空的，里面没有eeprom地址，因此我们在构造函数里面使用switch将属性12给每个对象从eeprom中读出来，如下所示：
```C
/*******************************************************************************************************************//**
 * 构造函数
 **********************************************************************************************************************/
MAYBE_UNUSED static void constructor(EventClass *obj, uint16_t name)  //构造函数,用于初始化对象
{
    uint16_t eeprom_addr = 0;
    if (Factory698Obj.ClassEvent698_ID7.obj_num < ARRAY_SIZE(Factory698Obj.ClassEvent698_ID7.obj))
    {
        Factory698Obj.ClassEvent698_ID7.obj[Factory698Obj.ClassEvent698_ID7.obj_num++] = obj;  /* 工厂类对象增加1 */
    }
    else
    {
        PRINTF_ERR("EventClass space is not enough, current obj add failed:0X%04X.", name);
    }
    switch (name)
    {
#if (defined(STEAL_EVENT_ENABLE) || defined(OVER_ERR_EVENT_ENABLE))
    case 0X3A06:  /* 窃电事件记录 */
        eeprom_addr = EVENT_698_STEAL_ADDR;
        break;
    case 0X3A08:  /* 超差事件记录 */
        eeprom_addr = EVENT_698_OVER_ERR_ADDR;
        break;
#endif
#ifdef METER_CLEAN_EVENT_ENABLE
    case 0X3013:  /* 电表清零事件 */
        eeprom_addr = EVENT_698_METER_CLEAN_ADDR;
        break;
#endif
#ifdef EVENT_CLEAN_EVENT_ENABLE
    case 0X3015:  /* 事件清零事件 */
        eeprom_addr = EVENT_698_EVENT_CLEAN_ADDR;
        break;
#endif
#if(0) /* 现由计量芯支持校时事件 */
    case 0X3016:  /* 校时事件 */
        eeprom_addr = EVENT_698_SET_TIME_ADDR;
        break;
#endif
#ifdef PROGRAME_EVENT_ENABLE
    case 0X3012:  /* 编程事件 */
        eeprom_addr = EVENT_698_PROGRAME_ADDR;
        break;
#endif
    default:
        break;
    }
    memset(&obj->manage, 0, sizeof(obj->manage));
    if (eeprom_backup_read(eeprom_addr, &obj->manage, sizeof(obj->manage)))
    {
        /* eeprom读取失败,恢复默认 */
        eeprom_restore_management_defaults(obj, true);
    }

    obj->sum_time = obj->manage.time_sum;
}
```
前面的就是将该对象加入到工厂里面去，用于工厂访问该对象，然后switch里面就是根据不同的事件记录拿到对应的eeprom地址，然后进行读取，如果是首次上电或者说读取的校验不对，那么该对象的属性12将恢复默认值，然后主站在每次读数据的时候都会对这个属性12进行校验，如果校验不过，也会恢复默认值，恢复默认值的函数如下：
```C
/**
 * @brief 事件数据恢复eeprom并清除flash
 *
 * @param obj 事件对象
 * @param ctrl true-恢复出厂设置,包括oad恢复默认值,记录序号,累加时间,当前记录数清零,清除flash中所存记录
               false-复位,仅当前记录数清零,清除flash中所存记录
 */
static void eeprom_restore_management_defaults(EventClass *const obj, bool select)
{
    RTOS_LOCK();
    switch (obj->name)
    {
#if (defined(STEAL_EVENT_ENABLE) || defined(OVER_ERR_EVENT_ENABLE))
    case 0x3A06:  /* 窃电事件记录恢复默认 */
    {
        /* 窃电事件关联对象表 */
        if (select)
        {
            memset(&obj->manage.oad[0], 0XFF, sizeof(obj->manage.oad));
            event_form_t form[] =
            {
                {0x20002200, 11, 0}, //电压 发生时刻前   Long64-unsigned,换算-6
                {0x20012200, 17, 0}, //电流 发生时刻前   Long64-unsigned,换算-6
                {0x20012A00, 3, 0}, //电流方向 发生时刻前   Long64-unsigned,换算-6
                {0x20042200, 22, 0}, //有功功率 发生时刻前  Long64-unsigned,换算-6
            };
            memcpy(&obj->manage.oad[0], &form[0], sizeof(form));
            /* 计算单条记录所占flash空间,可能后期会随关联对象表的设置而浮动 */
            uint16_t size = 0;
            size += sizeof(steal_electricity_event_record_head_t);

            for (uint8_t i = 0; i < ARRAY_SIZE(form); i++)
            {
                size += form[i].len;
            }
            size += 2; /* CRC */
            obj->manage.flash_one_record_size = size;  /* 配置单条记录长度 */
            obj->manage.report_id = EVENT_OCCUR_REPORT;
            obj->manage.report_method = EVENT_ACTIVE_REPORT;
        }
        obj->manage.eeprom_addr = EVENT_698_STEAL_ADDR;
        obj->manage.next_write_addr = FLASH_698_EVENT_STEAL_ADDR;
        obj->manage.flash_start_addr = FLASH_698_EVENT_STEAL_ADDR;
        obj->manage.flash_max_page = FLASH_698_EVENT_STEAL_PAGE;

        PRINTF("\r\nRecovery steal electricity event, default param:");
        PRINTF("eeprom addr: 0x%04X", obj->manage.eeprom_addr);
        PRINTF("flash next write addr: 0x%08X", obj->manage.next_write_addr);
        PRINTF("flash start addr: 0x%08X", obj->manage.flash_start_addr);
        PRINTF("flash max page: %u",  obj->manage.flash_max_page);
        PRINTF("flash max size: %u byte",  obj->manage.flash_max_page * FLASH_PAGE_SIZE);
        PRINTF("flash one record size: %u byte",  obj->manage.flash_one_record_size);
        PRINTF("flash maximum number of records: %u.\r\n",  obj->manage.flash_max_page * FLASH_PAGE_SIZE / obj->manage.flash_one_record_size);
        break;
    }    
#endif    
```
比如说窃电事件记录，在恢复默认的时候就是相当于将所有记录都清空，然后给属性12赋上初始flash地址和eepom地址信息，然后在擦除该属性分配的flash空间，相当于进行了一次数据清零操作。
## 触发事件
事件的触发依靠方法4 action，咱们的5个事件记录的需求，基本上都是手动触发的，因此咱们手动调用方法action中的方法2，比如要调用校时事件记录的action中的方法2执行一次事件记录：
```C
    /* 写入校时事件记录 */
    data[0] = CLASS_DT_ENUM;
    data[1] = EVENT_BEFORE_THE_START;
    data[2] = CLASS_DT_DATETIME_S;
    memcpy(&data[3], new_time, sizeof(data_time_s));
    Factory698Obj.action_698obj(&Factory698Obj, 0x30160200, data, 10);
```
只需要访问工厂即可，data里面是调用的参数，首先调用方法2的时候必须要带入事件类型，事件类型一共有2种，分别是事件发生时、事件结束后，用于让方法2 知道当前要存的是哪种事件。
方法2 如下所示：
```C
    case 2: /* 执行,产生一个事件 */
		
        if (param == NULL)
        {
            return CLASS_TYPE_UNMATCHED;
        }
        if (param[0] == CLASS_DT_ENUM && n >= 2)
        {
            PRINTF("Trigger an event, oi:0x%02X, type:%u", obj->name, param[2]);
            return write_event_record(obj, (event_occur_states_t)param[1], &param[2]);
        }
        else
        {
            PRINTF("Trigger event tag err, tag: 0x%02x, should be 0x%02x.", param[0], CLASS_DT_ENUM);
            return CLASS_TYPE_UNMATCHED;
        }
        break;
```
## 写入事件
执行方法2后会调用事件记录写入函数，写入函数就会根据该对象的属性12将记录写入flash。
### 写入流程
![image](http://172.17.0.100:8080/wangrui/lc_manage_project_new/-/raw/master/doc/figures/49.png?inline=false)

以下为标准事件记录格式和窃电事件记录格式
```C
/**
 * @brief 标准事件记录格式定义
 *
 */
typedef struct
{
    uint8_t index[4];  /* 事件记录序号 */
    uint8_t occur_time[7];  /* 事件发生时间 */
    uint8_t end_time[7];  /* 事件结束时间 */
    uint8_t source[7];   /* 发生源,以TSA地址长度设定 */
    uint8_t report_state; /* 上报状态,可以固定为NULL */
} event_record_head_t;

/* 窃电事件记录格式定义 */
typedef struct
{
    uint8_t index[4];  /* 事件记录序号 */
    uint8_t occur_time[7];  /* 事件发生时间 */
    uint8_t end_time[7];  /* 事件结束时间 */
    uint8_t source_meter_addr[7];   /* TSA地址 */
    struct
    {
        uint8_t oad[4];
        union
        {
            uint8_t report_state;
            uint8_t event_occur_report : 1;  /* 事件发生上报标识,0?未上报,1?已上报 */
            uint8_t event_occur_report_confirm : 1;  /* 事件发生上报确认标识,0?未确认,1?已确认 */
            uint8_t event_end_report : 1;  /* 事件结束(恢复)上报标识,0?未上报,1?已上报 */
            uint8_t event_end_report_confirm : 1;  /* 事件结束(恢复)上报确认标识,0?未确认,1?已确认 */
            uint8_t res : 4;  /* 预留 */
        } report;
    } channel_report_state[2];  /* array 通道上报状态,载波通道和RS485通道 */
    uint8_t active_power_sum[4];  /* 窃电时刻户表有功率之和,double-long_unsigned,w */
    struct
    {
        uint8_t duration;  /* 时长,单位 小时 */
        uint8_t active_power_sum[4];  /* 电能量,double-long_unsigned,kw,-2 */
    } recent_time_combination_active_switch;     /* 近段时间量测开关组合有功总电能消耗 */
    struct
    {
        uint8_t duration;  /* 时长,单位 小时 */
        uint8_t active_power_sum[4];  /* 电能量,double-long_unsigned,kw,-2 */
    } recent_time_combination_active_meter;     /* 近段时间电能表组合有功总电能消耗 */
    uint8_t steal_electricity_meter_num;  /* 窃电电表个数,最多储存10条 unsigned */
    uint8_t steal_electricity_meter_addr[STEAL_EVENT_MAX_METER_NUM][7];  /* 窃电电表地址,最多储存32条 */
} steal_electricity_event_record_head_t;  /* 窃电事件记录表头部信息 */
```
### 函数实现
写入接口如下：

```C
static uint8_t write_event_record(EventClass *const obj, event_occur_states_t event_status, const uint8_t *const param)
{
    uint8_t i;
    uint16_t write_index = 0;
    uint16_t len_temp = 0;
    data_time_s systime;
    uint16_t crc;

    ASSERT(param != NULL);
    rtc_get_time(&systime);
    event_manage_t manage_temp;
    static uint8_t write_cache[MAX_FLASH_SIZE_ONE_RECORD];

    memset(write_cache, 0XFF, sizeof(write_cache));
    /* 先校验eeprom管理信息 */
    if (eeprom_backup_read(obj->manage.eeprom_addr, &obj->manage, sizeof(obj->manage)))
    {
        /* eeprom读取失败,恢复默认 */
        eeprom_restore_management_defaults(obj, true);
    }
    memcpy(&manage_temp, &obj->manage, sizeof(manage_temp));
    switch (event_status)
    {
    case EVENT_BEFORE_THE_START:  /* 事件发生前 */
    {
        if (manage_temp.event_start_flag != true || manage_temp.event_end_flag != true)
        {
            PRINTF_ERR("last event was not completed, reject write new event.");
            return CLASS_TYPE_UNMATCHED;
        }

		if ((obj->name == 0X301D || obj->name == 0X301E || obj->name == 0X300F || obj->name == 0X3010 || obj->name == 0X302D || obj->name == 0X3011))  /* 瞬时事件处理 */
		{
		    /* 更新事件标志，不论存储成功与否更新事件标志，避免存储失败时不断触发事件 */
		    taskENTER_CRITICAL();
            obj->manage.event_start_flag = true;
            obj->manage.event_end_flag =  false;
			taskEXIT_CRITICAL();
		}
		
        PRINTF("Write event beforehand.");
        manage_temp.num_count++;    /* 事件记录序号加1 */
        /* 当前记录数加1 */
        manage_temp.current_record_number++;
        if (manage_temp.current_record_number > ((manage_temp.flash_max_page - FLASH_SECTOR_PAGE_NUM) * FLASH_PAGE_SIZE / obj->manage.flash_one_record_size))
        {
            manage_temp.current_record_number = (manage_temp.flash_max_page - FLASH_SECTOR_PAGE_NUM) * FLASH_PAGE_SIZE / obj->manage.flash_one_record_size;
        }
        if (obj->name == 0X3A06 || obj->name == 0X3A08) /* 特殊的窃电或超差事件记录 */
        {
#if (defined(STEAL_EVENT_ENABLE) || defined(OVER_ERR_EVENT_ENABLE))
            /* 组织窃电或超差事件记录头部信息域,TODO:参数如何计算待定 */
            steal_electricity_event_record_head_t head = {0};
            head.index[0] = (uint8_t)((manage_temp.num_count - 1) >> 24);
            head.index[1] = (uint8_t)((manage_temp.num_count - 1) >> 16);
            head.index[2] = (uint8_t)((manage_temp.num_count - 1) >> 8);
            head.index[3] = (uint8_t)(manage_temp.num_count - 1);
            memcpy(head.occur_time, &systime, 7);
            SWAP_AB(head.occur_time[0], head.occur_time[1]);
            memset(head.end_time, 0XFF, 7); /* 事件结束时间为空 */
            memset(head.source_meter_addr, 0XFF, 7);/* 事件发生源为空 */
            /* 事件上报状态为空 */
            memset(&head.channel_report_state[0].oad[0], 0XFF, 4);
            head.channel_report_state[0].report.report_state = 0XFF;
            memset(&head.channel_report_state[1].oad[0], 0XFF, 4);
            head.channel_report_state[1].report.report_state = 0XFF;
            /* 计算窃电或超差时刻有功功率之和 */
            if (param[0] == CLASS_DT_DOUBLE_LONG_UNSIGNED32)
            {
                memcpy(&head.active_power_sum[0], &param[1], 4);
            }
            else
            {
                PRINTF_ERR("trigger event %04X active power sum tag err.", obj->name);
                return CLASS_TYPE_UNMATCHED;
            }
            /* 计算近段时间开关组合有功总电能消耗 */
            if (param[5] == CLASS_DT_STRUCTURE && param[6] == 2 && param[7] == CLASS_DT_UNSIGNED8 && \
                    param[9] == CLASS_DT_DOUBLE_LONG_UNSIGNED32)
            {
                head.recent_time_combination_active_switch.duration = param[8];
                head.recent_time_combination_active_switch.active_power_sum[0] = param[10];
                head.recent_time_combination_active_switch.active_power_sum[1] = param[11];
                head.recent_time_combination_active_switch.active_power_sum[2] = param[12];
                head.recent_time_combination_active_switch.active_power_sum[3] = param[13];
            }
            else
            {
                PRINTF_ERR("trigger event %04X recent time combination active switch tag err.", obj->name);
                return CLASS_TYPE_UNMATCHED;
            }
            /* 计算近段时间电能表组合有功总电能消耗 */
            if (param[14] == CLASS_DT_STRUCTURE && param[15] == 2 && param[16] == CLASS_DT_UNSIGNED8 && \
                    param[18] == CLASS_DT_DOUBLE_LONG_UNSIGNED32)
            {
                head.recent_time_combination_active_meter.duration = param[17];
                head.recent_time_combination_active_meter.active_power_sum[0] = param[19];
                head.recent_time_combination_active_meter.active_power_sum[1] = param[20];
                head.recent_time_combination_active_meter.active_power_sum[2] = param[21];
                head.recent_time_combination_active_meter.active_power_sum[3] = param[22];
            }
            else
            {
                PRINTF_ERR("trigger event %04X recent time combination active meter tag err.", obj->name);
                return CLASS_TYPE_UNMATCHED;
            }
            /* 获取窃电或超差电表个数 */
            if (param[23] == CLASS_DT_UNSIGNED8 && param[24] == param[26] && param[25] == CLASS_DT_ARRAY)
            {
                head.steal_electricity_meter_num = param[24];
            }
            else
            {
                PRINTF_ERR("trigger event %04X steal electricity meter data tag err.", obj->name);
                return CLASS_TYPE_UNMATCHED;
            }
            /* 获取窃电或超差电表地址 */
            uint8_t meter_num = head.steal_electricity_meter_num;
            if (meter_num > STEAL_EVENT_MAX_METER_NUM)
            {
                meter_num = STEAL_EVENT_MAX_METER_NUM;
            }
            for (i = 0; i < STEAL_EVENT_MAX_METER_NUM; i++)
            {
                if (i < meter_num)
                {
                    if (param[i * 9 + 27] == CLASS_DT_TSA && param[i * 9 + 28] == 7)
                    {
                        head.steal_electricity_meter_addr[i][0] = param[i * 9 + 29];
                        head.steal_electricity_meter_addr[i][1] = param[i * 9 + 30];
                        head.steal_electricity_meter_addr[i][2] = param[i * 9 + 31];
                        head.steal_electricity_meter_addr[i][3] = param[i * 9 + 32];
                        head.steal_electricity_meter_addr[i][4] = param[i * 9 + 33];
                        head.steal_electricity_meter_addr[i][5] = param[i * 9 + 34];
                        head.steal_electricity_meter_addr[i][6] = param[i * 9 + 35];
                    }
                    else
                    {
                        PRINTF_ERR("trigger event %04X steal electricity meter address tag err.", obj->name);
                        return CLASS_TYPE_UNMATCHED;
                    }
                }
                else
                {
                    memset(&head.steal_electricity_meter_addr[i], 0xFF, 7);
                }
            }
            memcpy(write_cache, &head, sizeof(head));
            write_index += sizeof(head);
#endif
        }
        else  /* 普通事件 */
        {
            /* 组织事件记录头部信息域 */
            event_record_head_t head = {0};
            head.index[0] = (uint8_t)((manage_temp.num_count - 1) >> 24);
            head.index[1] = (uint8_t)((manage_temp.num_count - 1) >> 16);
            head.index[2] = (uint8_t)((manage_temp.num_count - 1) >> 8);
            head.index[3] = (uint8_t)(manage_temp.num_count - 1);
            memcpy(head.occur_time, &systime, 7);
            SWAP_AB(head.occur_time[0], head.occur_time[1]);
            memset(head.end_time, 0XFF, 7); /* 事件结束时间暂为空 */
            /* 断路器告警、分合闸和无功组合方式编程事件发生源enum*/
            if (obj->name == 0X3506 || obj->name == 0X301F || obj->name == 0X3020 || obj->name == 0X3023)
            {
                if (param[0] == CLASS_DT_ENUM)
                {
                    head.source[0] = param[1];
                }
                else
                {
                    PRINTF_ERR("trigger event %04X source data tag err.", obj->name);
                    return CLASS_TYPE_UNMATCHED;
                }
            }
            else if (obj->name == 0X3505)
            {
                /* 保护功能投退事件发生源为TSA */
                memset(&head.source, 0XFF, 7); /* 暂固定填NULL */
            }
            else if (obj->name == 0X3E10)
            {
#ifdef OVERTEMP_EVENT_ENABLE
                /* 温度告警事件发生源暂存告警标志及告警原因 */
                if (param[0] == CLASS_DT_ENUM && param[2] == CLASS_DT_LONG_UNSIGNED16)
                {
                    head.source[0] = param[1]; /* 告警标志,1-发生,0-恢复 */
                    head.source[1] = param[3]; /* 告警原因,2字节    param[1]固定为O*/
                    head.source[2] = param[4]; /* param[2]为告警原因 */
                }
                else
                {
                    PRINTF_ERR("trigger event %04X source data tag err.", obj->name);
                    return CLASS_TYPE_UNMATCHED;
                }
#endif
            }
            else
            {
                memset(&head.source, 0XFF, 7); /* 其他事件发生源固定填NULL */
            }
            head.report_state = 0XFF;
            memcpy(write_cache, &head, sizeof(head));
            write_index += sizeof(head);

            if (obj->name == 0X3012)/* 编程事件添加列表,固定为NULL */
            {
#ifdef PROGRAME_EVENT_ENABLE
                if (param[0] == CLASS_DT_OAD || param[0] == CLASS_DT_OMD)
                {
                    /* 目前仅存一个oad,其余均为空 */
                    memcpy(&s_eventprogram_oad_buffer[0][0], &param[0], 5);
                    memcpy(&write_cache[write_index], &s_eventprogram_oad_buffer, sizeof(s_eventprogram_oad_buffer));
                    write_index += sizeof(s_eventprogram_oad_buffer);
                }
                else
                {
                    PRINTF_ERR("trigger event %04X data tag err.", obj->name);
                    return CLASS_TYPE_UNMATCHED;
                }
#endif
            }
            else if (obj->name == 0X3015) /* 事件清零事件 */
            {
                memcpy(&write_cache[write_index], &s_eventclean_omd_buffer, sizeof(s_eventclean_omd_buffer));
                write_index += sizeof(s_eventclean_omd_buffer);
            }
            else if (obj->name == 0X3505) /* 保护功能投退事件 */
            {
                memcpy(&write_cache[write_index], param, 18);
                write_index += 18;
            }
        }
        /* 组织事件记录数据域 */
        for (i = 0; i < ARRAY_SIZE(manage_temp.oad); i++)
        {
            if (manage_temp.oad[i].oad == 0XFFFFFFFFU)
            {
                break;  /* 读取关联对象结束 */
            }
            /* 电压或电流不平衡事件需要读一条事件结束前,其他均为事件发生前 */
            if (((manage_temp.oad[i].oad & BEFORE_THE_EVENT_START) == 0x00002000) || ((manage_temp.oad[i].oad & BEFORE_THE_EVENT_END) == 0x00006000))
            {
                /* 事件发生时间为校时前时间 */
                if (manage_temp.oad[i].oad == (0X40000200 | BEFORE_THE_EVENT_START))
                {
                    write_cache[write_index++] = CLASS_DT_DATETIME_S;
                    memcpy(&write_cache[write_index], &systime, 7);
                    SWAP_AB(write_cache[write_index], write_cache[write_index + 1]);
                    write_index += 7;
                    continue;
                }

                if (CLASS_SUCCESS == Factory698Obj.get_698obj_data(&Factory698Obj, manage_temp.oad[i].oad & 0xFFFF1FFF, &write_cache[write_index], &len_temp))
                {
                    if (manage_temp.oad[i].len == len_temp)
                    {
                        //PRINTF("Write event oad: 0X%04X", obj->manage.oad[i].oad);
                        write_index += len_temp;
                        continue;
                    }
                }
                memset(&write_cache[write_index], 0XFF, manage_temp.oad[i].len);
                PRINTF("Read data null.");
            }

#if(0) /* 现由计量芯支持校时事件 */
            /* 特殊处理的校时后时间 */
            if (manage_temp.oad[i].oad == (0X40000200 | AFTER_THE_EVENT_END) && param[0] == CLASS_DT_DATETIME_S)
            {
                PRINTF("Write oad: 0X%04X", manage_temp.oad[i].oad);
                memcpy(&write_cache[write_index], &param[0], 8);
                write_index += 8;
                continue;
            }
#endif
            /* 非事件发生前oad或读取事件发生前oad失败直接跳过此条oad */
            write_index += manage_temp.oad[i].len;
        }
        write_index += 2;  /* 最后两个字节是crc校验 */
        if (write_index != manage_temp.flash_one_record_size)
        {
            /* 记录长度不一致，eeprom恢复默认,并清除之前记录 */
            eeprom_restore_management_defaults(obj, true);
            /* 本次放弃记录 */
            PRINTF_ERR("event recording write length %u and design length %u does not match.", write_index, manage_temp.flash_one_record_size);
            return CLASS_HARDWARE_FAULT;
        }
        PRINTF("event record write to flash length: %u.", manage_temp.flash_one_record_size);
        uint16_t read_max_num = manage_temp.flash_max_page * FLASH_PAGE_SIZE / manage_temp.flash_one_record_size;
//        uint8_t *read_cache = (uint8_t *)pvPortMalloc(manage_temp.flash_one_record_size);
//        if (read_cache == NULL)
//        {
//            PRINTF_ERR("class event put pvPortMalloc failed.");
//            SYSTEM_RESET();
//        }
        do /* 找出全FF的地方写入,如果不为全FF跳过该条flash空间 */
        {	
            /* 判断本次写入是否跨扇区 */
            if ((manage_temp.next_write_addr + manage_temp.flash_one_record_size - 1) >
                    (manage_temp.flash_start_addr + manage_temp.flash_max_page * FLASH_PAGE_SIZE - 1))
            {
                /* 本条重新返回第一个扇区存储 */
                manage_temp.next_write_addr = manage_temp.flash_start_addr;
                if (flash_erase_sector(manage_temp.flash_start_addr, 1)) //擦除第一个扇区
                {
                    /* 擦除失败,本次不写入 */
                    PRINTF_ERR("flash erase failed.");
//                    if (read_cache != NULL)
//                    {
//                        vPortFree(read_cache);
//                    }
                    return CLASS_HARDWARE_FAULT;
                }
            }
            else
            {
                /* 判断本条记录结尾是否会切换扇区号, 或本次写入地址是扇区首地址,如果是的话就擦除下一个扇区 */
                if (flash_get_sector_num(manage_temp.next_write_addr + manage_temp.flash_one_record_size - 1)
                        > flash_get_sector_num(manage_temp.next_write_addr) || (manage_temp.next_write_addr % FLASH_SECTOR_SIZE) == 0)
                {
                    /* 本次写就跨扇区了,因此直接擦除下一个扇区 */
                    if (flash_erase_sector(manage_temp.next_write_addr + manage_temp.flash_one_record_size - 1, 1)) //擦除下一个扇区
                    {
                        /* 擦除失败,本次不写入 */
                        PRINTF_ERR("flash erase failed.");
//                        if (read_cache != NULL)
//                        {
//                            vPortFree(read_cache);
//                        }
                        return CLASS_HARDWARE_FAULT;
                    }
                }
            }

		break;
        }
        while (read_max_num--);
//        vPortFree(read_cache);

        crc = getCRC16(write_cache, manage_temp.flash_one_record_size - 2);
        write_cache[manage_temp.flash_one_record_size - 1] = (uint8_t)(crc >> 8U);
        write_cache[manage_temp.flash_one_record_size - 2] = (uint8_t)crc;
        if (flash_write(manage_temp.next_write_addr, write_cache, manage_temp.flash_one_record_size))
        {
            PRINTF_ERR("event record write flash fail.");
            return CLASS_HARDWARE_FAULT;
        }

        /* 更新eeprom变量 */
        if (manage_temp.number_new < 0XFF)
            manage_temp.number_new++; /* 新增次数增加 */

        if (!(obj->name == 0X301D || obj->name == 0X301E || obj->name == 0X300F || obj->name == 0X3010 || obj->name == 0X302D || obj->name == 0X3011))  /* 瞬时事件处理 */
        {
            /* 如果是瞬时事件更新下一条地址,开关类事件增加新增次数 */
            manage_temp.next_write_addr += manage_temp.flash_one_record_size;
        }
        else
        {
            /* 本次事件已开始但未结束*/
            manage_temp.event_start_flag = true;
            manage_temp.event_end_flag =  false;
        }
        break;
    }

    case EVENT_AFTER_THE_END: /* 事件结束后 */
    {
        if (manage_temp.event_start_flag != true || manage_temp.event_end_flag != false)
        {
            PRINTF_ERR("This event was not start, reject write end events.");
            return CLASS_TYPE_UNMATCHED;
        }

		/* 更新事件标志，不论存储成功与否更新事件标志，避免存储失败时不断触发事件 */
		taskENTER_CRITICAL();
		obj->manage.event_end_flag = true;/* 本次事件已结束 */
		taskEXIT_CRITICAL();
		
        /* 读出本条数据 */
        if (flash_read(manage_temp.next_write_addr, write_cache, manage_temp.flash_one_record_size))
        {
            PRINTF_ERR("Non-instantane event read before record flash error.");
            /* 事件发生前记录异常,放弃本次事件并跳过本条记录*/
            manage_temp.event_end_flag = true;/* 本次事件已结束 */
            manage_temp.next_write_addr += manage_temp.flash_one_record_size;/* 更新flash地址 */
            manage_temp.cs = getCRC16((uint8_t *)&manage_temp, sizeof(manage_temp) - sizeof(uint16_t));
            taskENTER_CRITICAL();
            memcpy(&obj->manage, &manage_temp, sizeof(obj->manage));
            taskEXIT_CRITICAL();
            eeprom_backup_write((uint16_t)obj->manage.eeprom_addr, (uint8_t *)&obj->manage, sizeof(obj->manage));
            return CLASS_HARDWARE_FAULT;
        }

        /* 组织普通事件记录头部信息域,记录事件结束时间 */
        event_record_head_t *p_head = (event_record_head_t *)write_cache;
        memcpy(p_head->end_time, &systime, 7);
        SWAP_AB(p_head->end_time[0], p_head->end_time[1]);
        write_index += sizeof(event_record_head_t);

        /* 组织普通事件记录数据域,记录事件结束后关联oad */
        for (i = 0; i < ARRAY_SIZE(manage_temp.oad); i++)
        {
            if (manage_temp.oad[i].oad == 0XFFFFFFFFU)
            {
                break;  /* 读取关联对象结束 */
            }

            /* 记录事件结束后的关联oad           */
            if (((manage_temp.oad[i].oad & AFTER_THE_EVENT_END) == 0x00008000) || ((manage_temp.oad[i].oad & BEFORE_THE_EVENT_END) == 0x00006000))
            {
                PRINTF("Write event end oad: 0X%08X", manage_temp.oad[i].oad);

                /* 事件结束时记录事件发生期间电流/电压不平衡率并清零事件发生期间值 */
#ifdef UNBLANVOL_EVENT_ENABLE
                if (manage_temp.oad[i].oad == 0x20266200 && obj->name == 0X301D)
                {
                    write_cache[write_index++] = CLASS_DT_LONG_UNSIGNED16;
                    write_cache[write_index++] = (uint8_t)(volunbl_occurevent >> 8);
                    write_cache[write_index++] = (uint8_t)volunbl_occurevent;

                    volunbl_occurevent = 0;
                    continue;
                }
#endif
#ifdef UNBLANCUR_EVENT_ENABLE
                if (manage_temp.oad[i].oad == 0x20276200 && obj->name == 0X301E)
                {
                    write_cache[write_index++] = CLASS_DT_LONG_UNSIGNED16;
                    write_cache[write_index++] = (uint8_t)(curunbl_occurevent >> 8);
                    write_cache[write_index++] = (uint8_t)curunbl_occurevent;

                    curunbl_occurevent = 0;
                    continue;
                }
#endif
#ifdef SERIOUSUNBLANCUR_EVENT_ENABLE
                if (manage_temp.oad[i].oad == 0x20276200 && obj->name == 0X302D)
                {
                    write_cache[write_index++] = CLASS_DT_LONG_UNSIGNED16;
                    write_cache[write_index++] = (uint8_t)(ser_curunbl_occurevent >> 8);
                    write_cache[write_index++] = (uint8_t)ser_curunbl_occurevent;

                    ser_curunbl_occurevent = 0;
                    continue;
                }
#endif
                if (CLASS_SUCCESS == Factory698Obj.get_698obj_data(&Factory698Obj, manage_temp.oad[i].oad & 0xFFFF1FFF, &write_cache[write_index], &len_temp))
                {
                    if (manage_temp.oad[i].len == len_temp)
                    {
                        write_index += len_temp;
                        continue;
                    }
                }
                memset(&write_cache[write_index], 0XFF, manage_temp.oad[i].len);
                /* 读取关联oad失败 */
                PRINTF("Read event end data null.");
            }

            /* 非事件结束后oad或读取事件结束后oad失败直接跳过此条oad */
            write_index += manage_temp.oad[i].len;
        }

        /* 当前记录值存入flash */
        write_index += 2;  /* 最后两个字节是crc校验 */
        if (write_index != manage_temp.flash_one_record_size)
        {
            /* 记录长度不一致，eeprom恢复默认,并清除之前记录 */
            eeprom_restore_management_defaults(obj, true);
            /* 本次放弃记录 */
            PRINTF_ERR("event recording write length %u and design length %u does not match.", write_index, obj->manage.flash_one_record_size);
            return CLASS_HARDWARE_FAULT;
        }
        PRINTF("event record write to flash length: %u.", manage_temp.flash_one_record_size);

        uint16_t crc = getCRC16(write_cache, manage_temp.flash_one_record_size - 2);
        write_cache[manage_temp.flash_one_record_size - 1] = (uint8_t)(crc >> 8U);
        write_cache[manage_temp.flash_one_record_size - 2] = (uint8_t)crc;
        if (flash_write(manage_temp.next_write_addr, write_cache, manage_temp.flash_one_record_size))
        {
            PRINTF_ERR("event record write flash fail.");
            return CLASS_HARDWARE_FAULT;
        }

        /*  更新eeprom变量 */
        manage_temp.event_end_flag = true;/* 本次事件已结束 */
#ifdef POWERDOWN_EVENT_ENABLE
        if (obj->name == 0X3011)
        {
            /* 掉电事件的累加事件按发生事件和结束事件算 */
            manage_temp.time_sum += my_mktime(p_head->end_time[0] << 8 | p_head->end_time[1], p_head->end_time[2], p_head->end_time[3], p_head->end_time[4], p_head->end_time[5], p_head->end_time[6])
                                    - my_mktime(p_head->occur_time[0] << 8 | p_head->occur_time[1], p_head->occur_time[2], p_head->occur_time[3], p_head->occur_time[4], p_head->occur_time[5], p_head->occur_time[6]);
            obj->sum_time = manage_temp.time_sum;
        }
        else
#endif
        {
            manage_temp.time_sum = obj->sum_time;/* 更新累加时间 */
        }
        manage_temp.next_write_addr += manage_temp.flash_one_record_size;/* 更新flash地址 */
        break;
    }
    default:
        PRINTF_ERR("trigger event type err, type: %u.", event_status);
        return CLASS_TYPE_UNMATCHED;
    }
    /* 存入flash后更新eeprom变量 */
    manage_temp.cs = getCRC16((uint8_t *)&manage_temp, sizeof(manage_temp) - sizeof(uint16_t));
    taskENTER_CRITICAL();
    memcpy(&obj->manage, &manage_temp, sizeof(obj->manage));
    taskEXIT_CRITICAL();
    eeprom_backup_write((uint16_t)obj->manage.eeprom_addr, (uint8_t *)&obj->manage, sizeof(obj->manage));
    return CLASS_SUCCESS;
}
```
**函数实现的流程：**
1.	验证属性12的CRC，方法就是调用一下eeprom读接口，该接口会先验证RAM中的crc
2.	根据事件类型(事件发生前、事件结束后)写入不同的参数；
3.	使用定义好的结构体先将头部数据组装好，比如标准的事件记录头部数据格式如下：

![image](http://172.17.0.100:8080/wangrui/lc_manage_project_new/-/raw/master/doc/figures/50.png?inline=false)

4.	头部数据组装好之后就开始组装数据域的数据，数据域就是n个关联对象的数据，关联对象由属性12中的oad数组觉得，如果空的话里面就是全0XFF，如下：

```C
/**
 * @brief 事件管理信息,用户维护事件记录对象
 *
 */
typedef struct
{
    uint32_t eeprom_addr;           /* eeprom只有2字节,为了对齐因此使用4字节 */
    uint32_t num_count;             /* 事件发生的总次数,发生过并且结束过才算一次 */
    uint32_t time_sum;              /* 事件发生的累计时间 */
    uint32_t next_write_addr;       /* 最新的一次数据写地址 */
    uint32_t flash_start_addr;      /* 分配的flash扇区起始地址 */
    uint16_t flash_one_record_size; /* 单条事件记录分配的flash大小(byte) */
    uint16_t flash_max_page;        /* 分配的flash扇区页数(page) */
    event_form_t oad[34];           /* 关联对象属性表, 默认+扩展最多允许34个 */
    uint16_t current_record_number; /* 当前记录数 */
    uint8_t number_new;             /* 新增次数 */
    bool event_start_flag;          /* 事件发生标志 */
    bool event_end_flag;            /* 事件结束标志 */
    event_report_identify_t report_id; /* 上报标识 */
    event_report_method_t report_method;          /* 上报方法 */
    uint8_t res[3];
    uint16_t cs;
} event_manage_t;
```

5.	通过属性中的oad将数据逐个读出来然后放入cache，如下：

```C
/* 组织事件记录数据域 */
        for (i = 0; i < ARRAY_SIZE(manage_temp.oad); i++)
        {
            if (manage_temp.oad[i].oad == 0XFFFFFFFFU)
            {
                break;  /* 读取关联对象结束 */
            }
            /* 电压或电流不平衡事件需要读一条事件结束前,其他均为事件发生前 */
            if (((manage_temp.oad[i].oad & BEFORE_THE_EVENT_START) == 0x00002000) || ((manage_temp.oad[i].oad & BEFORE_THE_EVENT_END) == 0x00006000))
            {
                /* 事件发生时间为校时前时间 */
                if (manage_temp.oad[i].oad == (0X40000200 | BEFORE_THE_EVENT_START))
                {
                    write_cache[write_index++] = CLASS_DT_DATETIME_S;
                    memcpy(&write_cache[write_index], &systime, 7);
                    SWAP_AB(write_cache[write_index], write_cache[write_index + 1]);
                    write_index += 7;
                    continue;
                }

                if (CLASS_SUCCESS == Factory698Obj.get_698obj_data(&Factory698Obj, manage_temp.oad[i].oad & 0xFFFF1FFF, &write_cache[write_index], &len_temp))
                {
                    if (manage_temp.oad[i].len == len_temp)
                    {
                        //PRINTF("Write event oad: 0X%04X", obj->manage.oad[i].oad);
                        write_index += len_temp;
                        continue;
                    }
                }
                memset(&write_cache[write_index], 0XFF, manage_temp.oad[i].len);
                PRINTF("Read data null.");
            }
            /* 非事件发生前oad或读取事件发生前oad失败直接跳过此条oad */
            write_index += manage_temp.oad[i].len;
        }
```
只有在数据读取成功后才会写入cache，如果数据是空或者读取错误，那么cache写入0XFF，以便于在读取的时候判断数据有效性。\
6.	cache中的数据组装好以后写入flash，并更新flash下次的地址，最后再将属性12的数据更新到eeprom中，如下：
```C
    write_index += 2;  /* 最后两个字节是crc校验 */
        if (write_index != manage_temp.flash_one_record_size)
        {
            /* 记录长度不一致，eeprom恢复默认,并清除之前记录 */
            eeprom_restore_management_defaults(obj, true);
            /* 本次放弃记录 */
            PRINTF_ERR("event recording write length %u and design length %u does not match.", write_index, manage_temp.flash_one_record_size);
            return CLASS_HARDWARE_FAULT;
        }
        PRINTF("event record write to flash length: %u.", manage_temp.flash_one_record_size);
        uint16_t read_max_num = manage_temp.flash_max_page * FLASH_PAGE_SIZE / manage_temp.flash_one_record_size;
        do /* 找出全FF的地方写入,如果不为全FF跳过该条flash空间 */
        {	
            /* 判断本次写入是否跨扇区 */
            if ((manage_temp.next_write_addr + manage_temp.flash_one_record_size - 1) >
                    (manage_temp.flash_start_addr + manage_temp.flash_max_page * FLASH_PAGE_SIZE - 1))
            {
                /* 本条重新返回第一个扇区存储 */
                manage_temp.next_write_addr = manage_temp.flash_start_addr;
                if (flash_erase_sector(manage_temp.flash_start_addr, 1)) //擦除第一个扇区
                {
                    /* 擦除失败,本次不写入 */
                    PRINTF_ERR("flash erase failed.");

                    return CLASS_HARDWARE_FAULT;
                }
            }
            else
            {
                /* 判断本条记录结尾是否会切换扇区号, 或本次写入地址是扇区首地址,如果是的话就擦除下一个扇区 */
                if (flash_get_sector_num(manage_temp.next_write_addr + manage_temp.flash_one_record_size - 1)
                        > flash_get_sector_num(manage_temp.next_write_addr) || (manage_temp.next_write_addr % FLASH_SECTOR_SIZE) == 0)
                {
                    /* 本次写就跨扇区了,因此直接擦除下一个扇区 */
                    if (flash_erase_sector(manage_temp.next_write_addr + manage_temp.flash_one_record_size - 1, 1)) //擦除下一个扇区
                    {
                        /* 擦除失败,本次不写入 */
                        PRINTF_ERR("flash erase failed.");
                        return CLASS_HARDWARE_FAULT;
                    }
                }
            }
		break;
        }
        while (read_max_num--);

        crc = getCRC16(write_cache, manage_temp.flash_one_record_size - 2);
        write_cache[manage_temp.flash_one_record_size - 1] = (uint8_t)(crc >> 8U);
        write_cache[manage_temp.flash_one_record_size - 2] = (uint8_t)crc;
        if (flash_write(manage_temp.next_write_addr, write_cache, manage_temp.flash_one_record_size))
        {
            PRINTF_ERR("event record write flash fail.");
            return CLASS_HARDWARE_FAULT;
        }

        /* 更新eeprom变量 */
        if (manage_temp.number_new < 0XFF)
            manage_temp.number_new++; /* 新增次数增加 */

        if (!(obj->name == 0X301D || obj->name == 0X301E || obj->name == 0X300F || obj->name == 0X3010 || obj->name == 0X302D || obj->name == 0X3011))  /* 瞬时事件处理 */
        {
            /* 如果是瞬时事件更新下一条地址,开关类事件增加新增次数 */
            manage_temp.next_write_addr += manage_temp.flash_one_record_size;
        }
        else
        {
            /* 本次事件已开始但未结束*/
            manage_temp.event_start_flag = true;
            manage_temp.event_end_flag =  false;
        }
        break;
    }
```
## 读取事件
### 读取流程
读取流程比较简单，比如读取上n次记录的流程和写入流程差不多，大体是以下流程：
- 验证属性12的CRC
```C
static uint8_t get_last_event_record(EventClass *const obj, uint16_t last_n, uint8_t *const destin, uint16_t *const out_len, bool hasTag)
{
    uint16_t write_index = 0;
    uint16_t i;
    uint32_t start_num, start_addr;
    uint32_t idle_byte;
    uint32_t flash_addr;
    static uint8_t last_record_cache[MAX_FLASH_SIZE_ONE_RECORD];

    ASSERT(obj != NULL);
    ASSERT(destin != NULL);
    ASSERT(out_len != NULL);

    if (last_n == 0)
    {
        return CLASS_READ_WRITE_DENIED;
    }
	
    /* 先读eeprom管理信息 */
    if (eeprom_backup_read(obj->manage.eeprom_addr, &obj->manage, sizeof(obj->manage)))
    {
        /* eeprom读取失败,恢复默认 */
        eeprom_restore_management_defaults(obj, true);
    }
```
- 计算当前要读的条数，然后在while循环中逐条读出
```C
    uint32_t max_num = obj->manage.flash_max_page * FLASH_PAGE_SIZE / obj->manage.flash_one_record_size; /* 最大能储存的条数 */
    if (obj->manage.current_record_number == 0 || last_n > obj->manage.current_record_number || last_n > max_num)
    {
        /* 要读的数据比储存的数量大,返回数据空 */
        PRINTF("Read event record number is too big, record number is %u,but read number is %u.", obj->manage.num_count, last_n);
        goto null_out;
    }
```
- 读不带类型的原始数据
```C
if (!hasTag)  /* 无需加码,输出纯数据 */
    {
        memcpy(destin, last_record_cache, obj->manage.flash_one_record_size - 2);
        write_index = obj->manage.flash_one_record_size - 2;
    }
```
- 读带698数据类型的数据，实际上就是在原始数据的基础上逐个上数据类型，比如：
```C
else  /* 需要给每个数据项加上数据类型 */
    {
        uint16_t oad_data_area_index;  /* oad数据域在读出的数据中的位置 */
        uint8_t null_data[50];
        memset(null_data, 0XFF, sizeof(null_data));

        destin[write_index++] = CLASS_DT_STRUCTURE;  /* 这条记录是结构体类型 */
        uint8_t struct_num_index = write_index;     /* 结构体成员数 */
        destin[write_index++] = 0;  /* 结构体的个数先填0 */

        /* 开始组帧头部分 */
        if (obj->name == 0X3A06 || obj->name == 0X3A08) /* 窃电事件和超差事件的特殊处理 */
        {
```
